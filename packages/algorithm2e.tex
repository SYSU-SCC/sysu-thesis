%  algorithm2e.tex --- doc of the package file for algorithms
%  
%  (c) 1995-1997 Christophe Fiorio, Tu-Berlin, Germany
%  (c) 1998-2013 Christophe Fiorio, Montpellier 2 University, France
%  
%  Report bugs and comments to:
%  christophe.fiorio@univ-montp2.fr
%
%  $Id: algorithm2e.tex,v 5.0 2013/01/06 14:44:54 cfiorio Exp $
%
\documentclass[a4paper]{article}

\usepackage{a4wide}
\usepackage[
  colorlinks%
  ,linktocpage%This puts the link on page number.
%  ,plainpages=false%This forces a unique identification of pages.
%  ,hypertexnames=true%This is necessary to have exact link on Index page.
%  ,pdfpagelabels%
  ,hyperindex
]{hyperref}

\renewcommand{\subsectionautorefname}{section}
\renewcommand{\subsubsectionautorefname}{section}
\usepackage{makeidx}
\usepackage{moreverb}
\usepackage[boxed,commentsnumbered]{algorithm2e}


\def\no{n$^\circ$}
\def\No{N$^\circ$}

%% macros for the macros !!
\newcommand\macind[1]{\index{#1@\texttt{$\protect\backslash$#1}|textit}}

\newcommand\almac[1]{$\backslash$\texttt{#1}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\almacp[2]{$\backslash$\texttt{#1\{#2\}}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\almacpp[3]{$\backslash$\texttt{#1\{#2\}\{#3\}}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\almacppp[4]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\almacpppp[5]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\almacpsix[7]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}\{#6\}\{#7\}}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\almacphuit[9]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}\{#6\}\{#7\}\{#8\}\{#9\}}\index{#1@\texttt{$\protect\backslash$#1}|textit}}
\newcommand\Alenv[1]{\texttt{#1}\index{#1@\texttt{#1}|textbf}}
\newcommand\Almac[1]{$\backslash$\texttt{#1}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacp[2]{$\backslash$\texttt{#1\{#2\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacpp[3]{$\backslash$\texttt{#1\{#2\}\{#3\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacppp[4]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacpppp[5]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacpsix[7]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}\{#6\}\{#7\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacpseven[8]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}\{#6\}\{#7\}\{#8\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}
\newcommand\Almacphuit[9]{$\backslash$\texttt{#1\{#2\}\{#3\}\{#4\}\{#5\}\{#6\}\{#7\}\{#8\}\{#9\}}\index{#1@\texttt{$\protect\backslash$#1}|textbf}}

%% macro for the options !!
% 2.40
\newcommand{\optalgopart}{\textsf{algopart}\index{french@\textsf{algopart}|textit}\xspace}
\newcommand{\optalgochapter}{\textsf{algochapter}\index{french@\textsf{algochapter}|textit}\xspace}
\newcommand{\optalgosection}{\textsf{algosection}\index{french@\textsf{algosection}|textit}\xspace}
%
\newcommand{\optslide}{\textsf{slide}\index{french@\textsf{slide}|textit}\xspace}
\newcommand{\optalgoe}{\textsf{algo2e}\index{french@\textsf{algo2e}|textit}\xspace}
\newcommand{\optenglish}{\textsf{english}\index{english@\textsf{english}|textit}\xspace}
\newcommand{\optfrench}{\textsf{french}\index{french@\textsf{french}|textit}\xspace}
\newcommand{\optgerman}{\textsf{german}\index{german@\textsf{german}|textit}\xspace}
\newcommand{\optngerman}{\textsf{ngerman}\index{ngerman@\textsf{ngerman}|textit}\xspace}
\newcommand{\optspanish}{\textsf{spanish}\index{spanish@\textsf{spanish}|textit}\xspace}
\newcommand{\optcroatian}{\textsf{croatian}\index{croatian@\textsf{croatian}|textit}\xspace}
\newcommand{\optportuguese}{\textsf{portuguese}\index{portuguese@\textsf{portuguese}|textit}\xspace}
\newcommand{\optczech}{\textsf{czech}\index{czech@\textsf{czech}|textit}\xspace}
\newcommand{\optitaliano}{\textsf{italiano}\index{italiano@\textsf{italiano}|textit}\xspace}
\newcommand{\optslovak}{\textsf{slovak}\index{slovak@\textsf{slovak}|textit}\xspace}
\newcommand{\optboxed}{\textsf{boxed}\index{boxed@\textsf{boxed}|textit}\xspace}
\newcommand{\optboxruled}{\textsf{boxruled}\index{boxruled@\textsf{boxruled}|textit}\xspace}
\newcommand{\optruled}{\textsf{ruled}\index{ruled@\textsf{ruled}|textit}\xspace}
\newcommand{\opttworuled}{\textsf{tworuled}\index{tworuled@\textsf{tworuled}|textit}\xspace}
\newcommand{\optalgoruled}{\textsf{algoruled}\index{algoruled@\textsf{algoruled}|textit}\xspace}
\newcommand{\optplain}{\textsf{plain}\index{plain@\textsf{plain}|textit}\xspace}
\newcommand{\optlined}{\textsf{lined}\index{lined@\textsf{lined}|textit}\xspace}
\newcommand{\optvlined}{\textsf{vlined}\index{vlined@\textsf{vlined}|textit}\xspace}
\newcommand{\optnoline}{\textsf{noline}\index{noline@\textsf{noline}|textit}\xspace}
\newcommand{\optlinesnumbered}{\textsf{linesnumbered}\index{linesnumbered@\textsf{linesnumbered}|textit}\xspace}
\newcommand{\optlinesnumberedhidden}{\textsf{linesnumberedhidden}\index{linesnumberedhidden@\textsf{linesnumberedhidden}|textit}\xspace}
\newcommand{\optcommentsnumbered}{\textsf{commentsnumbered}\index{commentsnumbered@\textsf{commentsnumbered}|textit}\xspace}
\newcommand{\optinoutnumbered}{\textsf{inoutnumbered}\index{inoutnumbered@\textsf{inoutnumbered}|textit}\xspace}
\newcommand{\opttitlenumbered}{\textsf{titlenumbered}\index{titlenumbered@\textsf{titlenumbered}|textit}\xspace}
\newcommand{\opttitlenotnumbered}{\textsf{titlenotnumbered}\index{titlenotnumbered@\textsf{titlenotnumbered}|textit}\xspace}
\newcommand{\optresetcount}{\textsf{resetcount}\index{resetcount@\textsf{resetcount}|textit}\xspace}
\newcommand{\optnoresetcount}{\textsf{noresetcount}\index{noresetcount@\textsf{noresetcount}|textit}\xspace}
\newcommand{\optalgonl}{\textsf{algonl}\index{algonl@\textsf{algonl}|textit}\xspace}
\newcommand{\optlongend}{\textsf{longend}\index{longend@\textsf{longend}|textit}\xspace}
\newcommand{\optshortend}{\textsf{shortend}\index{shortend@\textsf{shortend}|textit}\xspace}
\newcommand{\optnoend}{\textsf{noend}\index{noend@\textsf{noend}|textit}\xspace}
\newcommand{\optfigure}{\textsf{figure}\index{figure@\textsf{figure}|textit}\xspace}
\newcommand{\optscright}{\textsf{scright}\index{scright@\textsf{scright}|textit}\xspace}
\newcommand{\optscleft}{\textsf{scleft}\index{scleft@\textsf{scleft}|textit}\xspace}
\newcommand{\optfillcomment}{\textsf{fillcomment}\index{fillcomment@\textsf{fillcomment}|textit}\xspace}
\newcommand{\optnofillcomment}{\textsf{nofillcomment}\index{nofillcomment@\textsf{nofillcomment}|textit}\xspace}
\newcommand{\optdotocloa}{\textsf{dotocloa}\index{dotocloa@\textsf{dotocloa}|textit}\xspace}
\newcommand{\optendfloat}{\textsf{endfloat}\index{endfloat@\textsf{endfloat}|textit}\xspace}
\newcommand{\optnorelsize}{\textsf{norelsize}\index{norelsize@\textsf{norelsize}|textit}\xspace}
\newcommand{\optonelanguage}{\textsf{onelanguage}\index{onelanguage@\textsf{onelanguage}|textit}\xspace}
\newcommand{\optrightnl}{\textsf{rightnl}\index{rightnl@\textsf{rightnl}|textit}\xspace}
\newcommand{\optprocnumbered}{\textsf{procnumbered}\index{procnumbered@\textsf{procnumbered}|textit}\xspace}
\newcommand{\optoldcommands}{\textsf{oldcommands}\index{oldcommands@\textsf{oldcommands}|textit}\xspace}
\newcommand{\optnokwfunc}{\textsf{nokwfunc}\index{nokwfunc@\textsf{nokwfunc}|textit}\xspace}
\newcommand{\optblockmarkers}{\textsf{displayblockmarkers}\index{displayblockmarkers@\textsf{displayblockmarkers}|textit}\xspace}
%
\newcommand{\Optfrench}{\textsf{french}\index{french@\textsf{french}|textbf}\xspace}
\newcommand{\Optenglish}{\textsf{english}\index{english@\textsf{english}|textbf}\xspace}
\newcommand{\Optgerman}{\textsf{german}\index{german@\textsf{german}|textbf}\xspace}
\newcommand{\Optngerman}{\textsf{ngerman}\index{ngerman@\textsf{ngerman}|textbf}\xspace}
\newcommand{\Optspanish}{\textsf{spanish}\index{spanish@\textsf{spanish}|textbf}\xspace}
\newcommand{\Optcroatian}{\textsf{croatian}\index{croatian@\textsf{croatian}|textbf}\xspace}
\newcommand{\Optportugues}{\textsf{portugues}\index{portugues@\textsf{portugues}|textbf}\xspace}
\newcommand{\Optczech}{\textsf{czech}\index{czech@\textsf{czech}|textbf}\xspace}
\newcommand{\Optitaliano}{\textsf{italiano}\index{italiano@\textsf{italiano}|textbf}\xspace}
\newcommand{\Optslovak}{\textsf{slovak}\index{slovak@\textsf{slovak}|textbf}\xspace}
\newcommand{\Optboxed}{\textsf{boxed}\index{boxed@\textsf{boxed}|textbf}\xspace}
\newcommand{\Optboxruled}{\textsf{boxruled}\index{boxruled@\textsf{boxruled}|textbf}\xspace}
\newcommand{\Optruled}{\textsf{ruled}\index{ruled@\textsf{ruled}|textbf}\xspace}
\newcommand{\Opttworuled}{\textsf{tworuled}\index{tworuled@\textsf{tworuled}|textbf}\xspace}
\newcommand{\Optalgoruled}{\textsf{algoruled}\index{algoruled@\textsf{algoruled}|textbf}\xspace}
\newcommand{\Optplain}{\textsf{plain}\index{plain@\textsf{plain}|textbf}\xspace}
\newcommand{\Optlined}{\textsf{lined}\index{lined@\textsf{lined}|textbf}\xspace}
\newcommand{\Optvlined}{\textsf{vlined}\index{vlined@\textsf{vlined}|textbf}\xspace}
\newcommand{\Optnoline}{\textsf{noline}\index{noline@\textsf{noline}|textbf}\xspace}
\newcommand{\Optlinesnumbered}{\textsf{linesnumbered}\index{linesnumbered@\textsf{linesnumbered}|textbf}\xspace}
\newcommand{\Optlinesnumberedhidden}{\textsf{linesnumberedhidden}\index{linesnumberedhidden@\textsf{linesnumberedhidden}|textbf}\xspace}
\newcommand{\Optcommentsnumbered}{\textsf{commentsnumbered}\index{commentsnumbered@\textsf{commentsnumbered}|textbf}\xspace}
\newcommand{\Optinoutnumbered}{\textsf{inoutnumbered}\index{inoutnumbered@\textsf{inoutnumbered}|textbf}\xspace}
\newcommand{\Opttitlenumbered}{\textsf{titlenumbered}\index{titlenumbered@\textsf{titlenumbered}|textbf}\xspace}
\newcommand{\Opttitlenotnumbered}{\textsf{titlenotnumbered}\index{titlenotnumbered@\textsf{titlenotnumbered}|textbf}\xspace}
\newcommand{\Optresetcount}{\textsf{resetcount}\index{resetcount@\textsf{resetcount}|textbf}\xspace}
\newcommand{\Optnoresetcount}{\textsf{noresetcount}\index{noresetcount@\textsf{noresetcount}|textbf}\xspace}
\newcommand{\Optalgonl}{\textsf{algonl}\index{algonl@\textsf{algonl}|textbf}\xspace}
\newcommand{\Optlongend}{\textsf{longend}\index{longend@\textsf{longend}|textbf}\xspace}
\newcommand{\Optshortend}{\textsf{shortend}\index{shortend@\textsf{shortend}|textbf}\xspace}
\newcommand{\Optnoend}{\textsf{noend}\index{noend@\textsf{noend}|textbf}\xspace}
\newcommand{\Optfigure}{\textsf{figure}\index{figure@\textsf{figure}|textbf}\xspace}
\newcommand{\Optscright}{\textsf{scright}\index{scright@\textsf{scright}|textbf}\xspace}
\newcommand{\Optscleft}{\textsf{scleft}\index{scleft@\textsf{scleft}|textbf}\xspace}
\newcommand{\Optfillcomment}{\textsf{fillcomment}\index{fillcomment@\textsf{fillcomment}|textbf}\xspace}
\newcommand{\Optnofillcomment}{\textsf{nofillcomment}\index{nofillcomment@\textsf{nofillcomment}|textbf}\xspace}
\newcommand{\Optdotocloa}{\textsf{dotocloa}\index{dotocloa@\textsf{dotocloa}|textbf}\xspace}
\newcommand{\Optendfloat}{\textsf{endfloat}\index{endfloat@\textsf{endfloat}|textbf}\xspace}
\newcommand{\Optnorelsize}{\textsf{norelsize}\index{norelsize@\textsf{norelsize}|textbf}\xspace}
\newcommand{\Optonelanguage}{\textsf{onelanguage}\index{onelanguage@\textsf{onelanguage}|textbf}\xspace}
\newcommand{\Optrightnl}{\textsf{rightnl}\index{rightnl@\textsf{rightnl}|textbf}\xspace}
\newcommand{\Optprocnumbered}{\textsf{procnumbered}\index{procnumbered@\textsf{procnumbered}|textbf}\xspace}
\newcommand{\Optoldcommands}{\textsf{oldcommands}\index{oldcommands@\textsf{oldcommands}|textbf}\xspace}
\newcommand{\Optnokwfunc}{\textsf{nokwfunc}\index{nokwfunc@\textsf{nokwfunc}|textbf}\xspace}
\newcommand{\Optblockmarkers}{\textsf{displayblockmarkers}\index{displayblockmarkers@\textsf{displayblockmarkers}|textbf}\xspace}
%%%
\newcommand{\ExampleOfAlgo}[1]{%
  \begin{minipage}{.4\textwidth}%
    \verbatiminput{#1}%
  \end{minipage}\hfill$\Longrightarrow$\hfill%
  \begin{minipage}{.45\textwidth}%
    \begin{algorithm}[H]%
      \input{#1}%
    \end{algorithm}%
  \end{minipage}%
}
%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\algocfversion}{release 5.0}
\title{algorithm2e.sty --- package for algorithms\\ {\large\algocfversion}}
\author{(c) 1995-1997 Christophe Fiorio, Tu-Berlin, Germany\\
(c) 1998-2013 Christophe Fiorio, LIRMM, Montpellier 2 University, France\\
  Report bugs and comments to cfiorio@um2.fr\\
  algorithm2esty-annonce@lirmm.fr mailing list for announcements\\
  algorithm2esty-discussion@lirmm.fr mailing list for discussion\thanks{The author is very grateful
    to David Carlisle, one of the authors of the LaTeX Companion book, for his advices} \thanks{Martin Blais for his
    suggestions} \thanks{David A. Bader for his new option
    \texttt{noend}} \thanks{Gilles Geeraerts for his new
    command \texttt{SetKwIfElseIf}} \thanks{Ricardo Fukasawa for the portuguese keywords} \thanks{Christian Icking 
  for the german translation of keywords} 
  \thanks{Arnaud Giersch for his suggestions and corrections on SetKwComments}
\thanks{and the many users as Jean-Baptiste Rouquier
  for their remarks} } \date{january 06 2013}

\makeindex

\begin{document}
\maketitle
\vspace{-0.5cm}

\tableofcontents
\clearpage

\section{Introduction}

Algorithm2e is an environment for writing algorithms in \LaTeX2e{}.  An algorithm is defined as a floating object
like figures.  It provides macros that allow you to create different sorts of key words, thus a set of predefined
key words is given. You can also change the typography of the keywords. See \autoref{longexample} for two long
examples of algorithms written with this package.


You can subscribe to \texttt{algorithm2e-announce} mailing list to receive
announcements about revisions of the package and to
\texttt{algorithm2e-discussion} to discuss, send comments,
ask questions about the package.
\makeatletter
In order to subscribe to the mailing lists you have to send an email to
\texttt{sympa@lirmm.fr} with \texttt{subscribe algorithm2e-announce Firstname
  Name} or\\\texttt{subscribe algorithm2e-discussion Firstname
  Name} in the body of the message.\makeatother

Changes from one release to the next are indicated in release notes at the beginning of the packages. For this
release (5.0), changes are indicated at the end of this document.

\section{How to use it: abstract}

You must set
\texttt{$\backslash$usepackage[\emph{options}]\{algorithm2e\}} before
\texttt{$\backslash$begin\{document\}} command. The available options
are described in \autoref{sec_options}.


The optional arguments [Hhtbp] works like those of figure environment.  The
\textbf{H} argument forces the algorithm to stay in place. If used, an algorithm
is no more a floating object.  Caution: algorithms cannot be cut, so if there is
not enough place to put an algorithm with H option at a given spot, \LaTeX\ will
place a blank and put the algorithm on the following page.


Here is a quick example\footnote{For longer and more complexe examples
  see \protect\autoref{longexample}}:

\begin{verbatim}
\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{this text}
  \KwResult{how to write algorithm with \LaTeX2e }
  
  initialization\;
  \While{not at end of this document}{
    read current\;
    \eIf{understand}{
      go to next section\;
      current section becomes this one\;
      }{
      go back to the beginning of current section\;
      }
    }
  \caption{How to write algorithms}
\end{algorithm}
\end{verbatim}

which gives

\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{this text}
  \KwResult{how to write algorithm with \LaTeX2e }

  initialization\;
  \While{not at end of this document}{
    read current section\;
    \eIf{understand}{
      go to next section\;
      current section becomes this one\;
    }{
      go back to the beginning of current section\;
    }
  }
  \caption{How to write algorithms}
\end{algorithm}

\textsc{Very Important} : each line \textbf{MUST} end with \almac{;}
only those with a macro beginning a block should not end with \almac{;}.
Note then that you can always use the \almac{;} command in math mode
to set a small space.

The caption works as in a figure environment, except that it should be located at the end of the algorithm. It is
used by \almac{listofalgorithms} as a reference name for the list of algorithms. You can also use the title macro
given with the package, but this macro doesn't insert an entry in the list of algorithms.
%%%%%%%%%%%%%
\section{Two more detailed examples}\label{longexample}


The \autoref{algo_disjdecomp} and \autoref{IR} are written with this package.

\subsection{Algorithm disjoint decomposition}

Here we suppose that we have done:
\begin{verbatim}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\end{verbatim}\index{lined|textit,algonl|textit,boxed|textit}

\noindent The \autoref{algo_disjdecomp} was written in \LaTeX2e code as presented next page. You can label lines,
and for example \autoref{forins} denotes the second \texttt{For} (see \almac{label} command in the example). Notice
also some ways of doing comments at lines~\ref{lt}, \ref{ut}, \ref{cmt} and \ref{lelse}. Star comment commands are
for comment on lines of code, else comment is a line by itself as at \autoref{cmt}. The different option in star
comments defines if it is left (\texttt{l} and \texttt{h}) or right justified (\texttt{r} and \texttt{f}). The
first ones (\texttt{l} and \texttt{r}) add $;$ at the end of line code, the second ones (\texttt{f} and \texttt{h})
doesn't. These last are useful when used in side comment (introduced by \texttt{()}) of alternatives of loops keyword
commands.
\RestyleAlgo{boxed}\LinesNumbered\input{algorithm2e_exAlgoDisjdecomp.tex}\par
\vspace{-10ex}\noindent\fbox{%
  \begin{minipage}[c]{\textwidth}%
    \verbatiminput{algorithm2e_exAlgoDisjdecomp.tex}%
  \end{minipage}\label{code:algodisjdecom}%
}%

\clearpage
\subsection{Algorithm: IntervalRestriction}
\def\theAlgoLine{\arabic{AlgoLine}}

Here we suppose we that have done:
\begin{verbatim}
\usepackage[ruled,vlined]{algorithm2e}
\end{verbatim}
\index{ruled|textit,vlined|textit}

The \LaTeX2e code on next page gives \autoref{IR}. Here lines are not autonumbered but you can number them
individually with \almac{nl} command as for \autoref{InRes1} or \autoref{InRes2}. You even can set your own
reference with \almac{nlset} command and get back this reference by simply using classical \almac{ref}. For
example \texttt{$\backslash$ref\{InResR\}} gives \ref{InResR}.\par
{%
  \RestyleAlgo{algoruled}\SetAlgoVlined\LinesNotNumbered\input{algorithm2e_exIR.tex}
  \noindent\fbox{%
    \begin{minipage}[c]{\textwidth}%
      \verbatiminput{algorithm2e_exIR.tex}%
    \end{minipage}\label{code:algoIR}%
  }}%
\par
\clearpage

%%%%%%%%%%%%%
\section{Genericity and example of languages}

In this section, we will try to show you main macros and how you can use this package to
suit your need. Based on one example using most popular algorithms expressions, we will
show you how it can be configured to be display in pseudo-code, in python or in C.

The following code shows how is typeset the generic example we'll use in this section:\par
{%
  \noindent\fbox{%
    \begin{minipage}[c]{\textwidth}%
      \verbatiminput{algorithm2e_exgeneric}%
    \end{minipage}\label{code:exgeneric}%
  }}%
\par\medskip
To handle \texttt{if} condition, use a macro to be abble to change it according to
language syntax, in particular we will change it for python-style and c-style. We also
define a function to write algorithm as a recursive function. These macros are defined as:\vspace{-1.5ex}
\begin{verbatim}
\newcommand{\forcond}{$i=0$ \KwTo $n$}
\SetKwFunction{FRecurs}{FnRecursive}%
\end{verbatim}

The \autoref{algo:pseudocode} shows how algorithm is displayed in pseudo-code with default
behaviour and options \texttt{boxed}, \texttt{commentsnumbered} and \texttt{longend}
set. Note that by default, lines are used to show block of code. Note also that
\texttt{longend} option makes package use special \emph{end} keyword for each
command\footnote{Default behaviour uses \emph{short end} keywords, it means typeseting only
  \emph{end}.}.
\SetKwProg{Fn}{Function}{}{end}\SetKwFunction{FRecurs}{FnRecursive}%
\newcommand{\forcond}{$i=0$ \KwTo $n$}
\begin{algorithm}\SetAlgoLongEnd
  \caption{Generic example with most classical expressions derived in pseudo-code}%
  \label{algo:pseudocode}
  \input{algorithm2e_exgeneric}
\end{algorithm}

The \autoref{algo:pseudocodeblock} shows how algorithm is displayed using automatic block
display (new feature since relase 5.0). To achieve this display, we only add following
macros at start of the algorithm:\vspace{-1.5ex}
\begin{verbatim}
\AlgoDisplayBlockMarkers\SetAlgoBlockMarkers{begin}{end}%
\SetAlgoNoEnd
\end{verbatim}
\vspace{-1.5ex}First one tells package to display blocks with keyword markers. Note that
the definition of block markers are the one by default. Last macro remove end keywords of
commands to avoid a double end (the one of block marker and the one of command).
\begin{algorithm}\AlgoDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoBlockMarkers{begin}{end}
  \caption{Generic example in pseudo-code with begin-end block set}\label{algo:pseudocodeblock}
  \input{algorithm2e_exgeneric}
\end{algorithm}\medskip

The \autoref{algo:pythoncodeblock} shows how algorithm looks like with a python-style
syntax. To achieve this display, we need to make following changes before the algorithm:\vspace{-1.5ex}
\begin{verbatim}
\SetStartEndCondition{ }{}{}%
\SetKwProg{Fn}{def}{\string:}{}
\SetKwFunction{Range}{range}%%
\SetKw{KwTo}{in}\SetKwFor{For}{for}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwFor{While}{while}{:}{fintq}%
\renewcommand{\forcond}{$i$ \KwTo\Range{$n$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
\end{verbatim}
\vspace{-1.5ex}\texttt{SetStartEndCondition} is used to display alternatives and loops
conditions according to python syntax: it means a space before condition, and no space
after since ':' marks end of condition. Functions are defined with \emph{def} in python,
so we redefine \texttt{$\backslash$Fn} macro. \texttt{Range} is a new macro for
\emph{range} python function. Next are redefined \emph{For}, \emph{If} and \emph{While}
commands accordingly to python syntax. Note that we do nothing for \emph{repeat-until}
command since it doesn't exist in python. For condition is redefined to match python
behaviour. At last we tell package to not display block, to
not display end keyword and to not print line according to python syntax.%
\renewcommand{\forcond}{$i$ \KwTo\Range{$n$}}
\begin{algorithm} \AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
  \SetStartEndCondition{ }{}{}%
  \SetKwProg{Fn}{def}{\string:}{}%
  \SetKw{KwTo}{in}\SetKwFunction{Range}{range}%
  \SetKwFor{For}{for}{\string:}{}%
  \SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
  \SetKwFor{While}{while}{:}{fintq}%
  \caption{Generic example in python-style like syntax}\label{algo:pythoncodeblock}
  \input{algorithm2e_exgeneric}
\end{algorithm}

The \autoref{algo:ccodeblock} shows how algorithm looks like with a c-style
syntax. To achieve this display, we need to make following changes before the algorithm:\vspace{-1.5ex}
\begin{verbatim}
\SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{\{}{\}}%
\SetKwProg{Fn}{}{}{}\SetKwFunction{FRecurs}{void FnRecursive}%
\SetKwFor{For}{for}{}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{}{elif}{else}{}%
\SetKwFor{While}{while}{}{}%
\SetKwRepeat{Repeat}{repeat}{until}%
\AlgoDisplayBlockMarkers\SetAlgoNoLine%
\end{verbatim}
\vspace{-1.5ex} \texttt{SetStartEndCondition} set braces around conditions like in C. We
want that each block is marked with \{ at start and \} at end, so we set it thanks to
\texttt{$\backslash$SetAlgoBlockMarkers} macro. \texttt{$\backslash$Fn} is redefined with
no keyword since in C, name of function defines it. Then we redefin \texttt{FnRecursive}
with its type. Next, \emph{For}, \emph{If}, \emph{While} and \emph{Repeat} are redefined
accordingly to C syntax. At last, we tell the package to display block markers.
\SetKwFunction{FRecurs}{void FnRecursive}%
\begin{algorithm}\AlgoDisplayBlockMarkers\SetAlgoNoLine%
  \SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{\{}{\}}%
  \SetKwProg{Fn}{}{}{}%
  \SetKwFor{For}{for}{}{}%
  \SetKwIF{If}{ElseIf}{Else}{if}{}{elif}{else}{}%
  \SetKwFor{While}{while}{}{}%
  \SetKwRepeat{Repeat}{repeat}{until}%
  \caption{Generic example in c-style like syntax}\label{algo:ccodeblock}
  \input{algorithm2e_exgeneric}
\end{algorithm}

The \autoref{algo:ccodeblockcf} shows how algorithm looks like with a c-style
syntax and a more compact way to mark blocks. To achieve this display, we need to make following changes before the algorithm:\vspace{-1.5ex}
\begin{verbatim}
\SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{\}}%
\SetKwProg{Fn}{}{\{}{}\SetKwFunction{FRecurs}{void FnRecursive}%
\SetKwFor{For}{for}{\{}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{\{}{elif}{else\{}{}%
\SetKwFor{While}{while}{\{}{}%
\SetKwRepeat{Repeat}{repeat\{}{until}%
\AlgoDisplayBlockMarkers\SetAlgoNoLine%
\end{verbatim}
\vspace{-1.5ex} If you look at \autoref{algo:pseudocode}, you can see that some command
doesn't put a end. For example, it is a case for a \emph{if} followed by an \emph{else},
same thing for a \emph{else if}. In C, there is always an end marker. So, to achieve our
goal we need to use end marker of blocks. But we don't want displaying begin marker as in
\autoref{algo:pseudocodeblock} or \autoref{algo:ccodeblock}. If begin block marker is set to
empty, then nothing is written (especially not a blank line). So we tell package to use
block markers with an empty marker for begin and a \} for end. Now we have to tell package
to write a \{ on the same line as commands. This is achieve by redefining \emph{If},
\emph{For}, \emph{While} and \emph{Repeat} command.
\begin{algorithm}\AlgoDisplayBlockMarkers\SetAlgoLongEnd\SetAlgoNoLine%
  \SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{\}}%
  \SetKwProg{Fn}{}{\{}{}%
  \SetKwFor{For}{for}{\{}{}%
  \SetKwIF{If}{ElseIf}{Else}{if}{\{}{elif}{else\{}{}%
  \SetKwFor{While}{while}{\{}{}%
  \SetKwRepeat{Repeat}{repeat\{}{until}%
  \caption{Generic example in c-style like syntax with compact block}\label{algo:ccodeblockcf}
  \input{algorithm2e_exgeneric}
\end{algorithm}


%%%%%%%%%%%%%
\section{Compatibility issues}

Compatibily with other packages improven by changing name of internal macros. Algorithm2e can now be used with
almost all package, as \texttt{elsart}\index{elsart}, \texttt{hermes}\index{hermes},
\texttt{arabtex}\index{arabtex} for example, if this last is loaded after algorithm2e package. So, at this time,
\algocfversion has few known compatibility problem with other packages. The packages or classes that are known to
be not compatible with \texttt{algorithm2e} package is:
\begin{itemize}
  \item \texttt{ascelike}\index{ascelike}
  \item \texttt{pstcol}\index{pstcol}
\end{itemize}
Nevertheless, when use with some packages, some of their options cannot be used, or you need to specify some
particular options (as \optalgoe to change name of environment if \texttt{algorithm} is already defined by the
class), either from \texttt{algorithm2e} package or from the other packages.
\begin{description}
  \item[hyperref\index{hyperref}] if you want to compile in Pdf\LaTeX, you must not use \texttt{naturalnames} option.
        \textbf{Beware} this has changed from release 3 where you should use it!
  \item[article-hermes\index{article-hermes}] is not compatible with relsize used by \texttt{algorithm2e} package, so
        you have to use \optnorelsize option to get algorithm works with \texttt{article-hermes} class.
\end{description}
Note also that, if you use packages changing the way references are printed, you must define labels of algorithm
\textbf{after} the caption to ensure a correct printing. You cannot use \almac{label} inside a caption without
errors.

\medskip
From release $4.0$, some commands have been renamed to have consistent naming (CamlCase syntax) and old commands
are no more available. If you doesn't want to change your mind or use old latex files, you have to use
\Optoldcommands option to enable old commands back. Here are these commands:
\begin{itemize}
  \item \almac{SetNoLine} becomes \almac{SetAlgoNoLine}
  \item \almac{SetVline}  becomes \almac{SetAlgoVlined}
  \item \almac{Setvlineskip}  becomes \almac{SetVlineSkip}
  \item \almac{SetLine}   becomes \almac{SetAlgoLined}
  \item \almac{dontprintsemicolon} becomes \almac{DontPrintSemicolon}
  \item \almac{printsemicolon} becomes \almac{PrintSemicolon}
  \item \almac{incmargin} becomes \almac{IncMargin}
  \item \almac{decmargin} becomes \almac{DecMargin}
  \item \almac{setnlskip} becomes \almac{SetNlSkip}
  \item \almac{Setnlskip} becomes \almac{SetNlSkip}
  \item \almac{setalcapskip} becomes \almac{SetAlCapSkip}
  \item \almac{setalcaphskip} becomes \almac{SetAlCapHSkip}
  \item \almac{nlSty} becomes \almac{NlSty}
  \item \almac{Setnlsty} becomes \almac{SetNlSty}
  \item \almac{linesnumbered} becomes \almac{LinesNumbered}
  \item \almac{linesnotnumbered} becomes \almac{LinesNotNumbered}
  \item \almac{linesnumberedhidden} becomes \almac{LinesNumberedHidden}
  \item \almac{showln} becomes \almac{ShowLn}
  \item \almac{showlnlabel} becomes \almac{ShowLnLabel}
  \item \almac{nocaptionofalgo} becomes \almac{NoCaptionOfAlgo}
  \item \almac{restorecaptionofalgo} becomes \almac{RestoreCaptionOfAlgo}
  \item \almac{restylealgo} becomes \almac{RestyleAlgo}
  \item \almac{gIf} macros and so on do no more exist
\end{itemize}

%%%%%%%%%%%%%
\section{Environments defined in the package\label{sec_envi}}

This package provides 4 environments :
\begin{description}
  \item[algorithm:] the main environment, the one you will used most of the
        time.
  \item[algorithm*:] same as the precedent, but used in a two columns text, puts
        the algorithm across the two columns.
  \item[procedure:] This environment works like algorithm environment but:
        \begin{itemize}
          \item the \texttt{ruled} (or \texttt{algoruled}) style is recommended.
          \item the caption now writes \textbf{Procedure name...}
          \item the syntax of the $\backslash$\texttt{caption} command is restricted as
                follow: you MUST put a name followed by 2 braces like this
                ``\emph{Name()}''.  You can put arguments inside the braces and text after.
                If no argument is given, the braces will be removed in the title.
          \item label now puts the name (the text before the braces in the caption) of
                the procedure or function as reference (not the number like a classic
                algorithm environment).
          \item name of the procedure or function set in caption is automatically defined as a KwFunction and so can be
                used as a macro. For example, if inside a procedure environment you set \almacp{caption}{myproc()}, you can use
                $\backslash$\texttt{myproc} macro in you main text. Beware that the macro is only defined after the
                \almac{caption}!
          \item \optnokwfunc unable the feature described above in function and procedure environment. Useful if you use
                name of procedure or function that cannot be a command name as a math display for example.
        \end{itemize}
  \item[procedure*:] same as the precedent, but used in a two columns text outs the
        procedure across the two columns.
  \item[function:] as the precedent but with \textbf{Function} instead of
        procedure in the title.
  \item[function*:] same as the precedent, but used in a two columns text outs the
        function across the two columns.
\end{description}

If you don't like algorithm or look for something else, you can change the name of algorithm by using command
below:
\begin{description}
  \item[\almacppp{SetAlgorithmName}{algorithmname}{algorithmautorefname}{list of algorithms name}] which redefines
        name of the algorithms and the sentence list of algorithms. Example:\\\noindent\almacpp{SetAlgorithmName}{Protocol}{List of
          protocols} if you prefer protocol than algorithm. Second argument is the name that \almac{autoref}, from
        \texttt{hyperref}\index{hyperref} package, will use.
\end{description}
The same exists for procedure and function environment, the difference is that list of algorithms is not change and
keep its original name:
\begin{description}
  \item[\Almacpp{SetAlgoProcName}{aname}{anautorefname}] sets the name of Procedure printed by procedure environment
        (the environment prints Procedure by default). Second argument is the name that \almac{autoref}, from
        \texttt{hyperref}\index{hyperref} package, will use.
  \item[\Almacpp{SetAlgoFuncName}{aname}{anautorefname}] sets the name of Function printed by procedure environment
        (the environment prints Function by default).  Second argument is the name that \almac{autoref}, from
        \texttt{hyperref}\index{hyperref} package, will use.
\end{description}

%%%%%%%%%%%%%

\section{The options of the package\label{sec_options}}


%--------------------------------------------------------------------------
\subsection{language option}
\label{sec:option:language}
\begin{description}
  \item[\Optcroatian:] to have for example \textsl{Algoritam:} instead of \textsl{algorithm:}.  \medskip
  \item[\Optczech:] to have for example \textsl{Algoritmus:} instead of \textsl{algorithm:}.
  \item[\Optenglish:] the default.
  \item[\Optfrench:] to have for example \textsl{algorithme\ :} instead of \textsl{algorithm:}.
  \item[\Optgerman:] to have for example \textsl{Prozedur\ :} instead of \textsl{procedure:}.  \medskip
  \item[\Optngerman:] to have german option as babel
  \item[\Optportugues:] to have for example \textsl{Algoritmo:} instead of \textsl{algorithm:}.  \medskip
  \item[\Optspanish:] to have for example \textsl{Algoritmo:} instead of \textsl{algorithm:}.  \medskip
  \item[\Optonelanguage:] allows, if using standard keywords listed below, to switch from one language to another
        without changing keywords by using appropriate language option:
        \begin{itemize}
          \item \texttt{KwIn, KwOut, KwData, KwResult}
          \item \texttt{KwTo KwFrom}
          \item \texttt{KwRet, Return}
          \item \texttt{Begin}
          \item \texttt{Repeat}
          \item \texttt{If, ElseIf, Else}
          \item \texttt{Switch, Case, Other}
          \item \texttt{For, ForPar, ForEach, ForAll, While}
        \end{itemize}
\end{description}

%--------------------------------------------------------------------------
\subsection{compatibility issue}
\label{sec:option:compatibility}

\begin{description}
  \item[\optalgoe:] changes the name of environment algorithm into algorithm2e
        and so allows to use the package with some journal style which already define
        an algorithm environment. Changes also the command name for the list of
        algorithms, it becomes \Almac{listofalgorithmes}
  \item[\Optendfloat:] endfloat packages doesn't allow float environment inside other environment. So using it with
        figure option of algorithm2e makes error. This option enables a new environment algoendfloat to be used instead
        of algorithm environment that put algorithm at the end. algoendfloat environment make algorithm acting as
        endfloat figures. This option load endfloat package, so it is required to have it.
  \item[\Optnorelsize:] starting from this release (v4.00), algorithm2e package uses relsize package in order to get
        relative size for lines numbers; but it seems that some rare classes (such as inform1.cls) are not compatible
        with relsize; to have algorithm2e working, this option makes algorithm2e not to load relsize package and go back
        to previous definition by using $\backslash$\texttt{scriptsize} font for lines numbers.
  \item[\optslide:] require package color. To be used with slide class in order to have correct margins.
  \item[\Optnokwfunc] disable the setting in \almac{KwFunction} of procedure's or function's name (see \autoref{sec_envi})
        of function and procedure environment. Useful if you use name of procedure or function that cannot be a command
        name as a math display for example.
\end{description}

%--------------------------------------------------------------------------
\subsection{environment display and use}
\label{sec:option:envdisplay}

%---------------------------------
\subsubsection{boxed, ruled, plain environment}
\label{sec:option:envdisplay:box}

\begin{description}
  \item[\Optboxed :] to have algorithms enclosed in a box.
  \item[\Optboxruled :] surround algorithm by a box, puts caption above and add a line after caption.
  \item[\Optruled :] to have algorithms with a line at the top and the bottom. Note that the caption is not centered
        under the algorithm anymore but is set at the beginning of the algorithm.
  \item[\Optalgoruled :] as above but with extra spaces after the rules.
  \item[\Opttworuled:] tworuled acts like ruled but doesn't put a line after the title.
  \item[\Optplain :] the default, with no feature.\par
\end{description}

%---------------------------------
\subsubsection{algorithm numbering}
\label{sec:option:envdisplay:numbers}

\begin{description}
  \item[\optalgochapter :] algorithms are numbered within chapter numbers.
  \item[\optalgosection :] (default) algorithms are numbered within section numbers.
  \item[\optalgopart :] algorithms are numbered within part numbers.\par\medskip
  \item[\Optprocnumbered:]  makes the procedure and function to be numbered as algorithm.
\end{description}

%---------------------------------
\subsubsection{figure and toc}
\label{sec:option:envdisplay:figuretoc}

\begin{description}
  \item[\Optfigure :] algorithms are put in classical figures and so are numbered as
        figures and putted in the $\backslash$\texttt{listoffigures}.\par
  \item[\Optdotocloa] adds an entry in the toc for the list of algorithms. This option loads package
        \texttt{tocbibind} if not already done and so list of figures and list of tables are also added in
        the toc. If you want to control which ones of the lists will be added in the toc, please load
        package \texttt{tocbibind} before package algorithm and give it the options you want.
\end{description}

%--------------------------------------------------------------------------
\subsection{code typesetting}
\label{sec:option:algodisplay}

%---------------------------------
\subsubsection{blocks display}
\label{sec:option:algodisplay:blocks}

\paragraph{lines}
\label{sec:option:algodisplay:blocks:lines}

\begin{description}
  \item[\Optlined:] \almac{SetAlgoLined} becomes the default, see
        \autoref{sec_styleoptions} for explanations about the
        \almac{SetAlgoLined} macros.
  \item[\Optvlined:] \almac{SetAlgoVlined} becomes the default, see
        \autoref{sec_styleoptions} for explanations about the
        \almac{SetAlgoVlined} macros.
  \item[\Optnoline:]  \almac{SetNoline} becomes the default, see
        \autoref{sec_styleoptions} for explanations about the
        \almac{SetNoline} macros.
\end{description}

\paragraph{block markers}
\label{sec:option:algodisplay:blocks:markers}

\begin{description}
  \item[\Optblockmarkers] \almac{AlgoDisplayBlockMarkers} becomes the default, see \autoref{sec_styleoptions}
        for explanations about the \almac{AlgoDisplayBlockMarkers} macro.
\end{description}

%---------------------------------
\subsubsection{end keywords}
\label{sec:option:algodisplay:endkeywords}

\begin{description}
  \item[\Optlongend] the end keyword are longer and different for
        each macro. For example \emph{endif} for a if-then-else macro.
  \item[\Optshortend] the ``end keyword'' of the macros is just
        \emph{end} (default).
  \item[\Optnoend] the ``end keyword'' of the macros is not printed.
\end{description}

%---------------------------------
\subsubsection{comments}
\label{sec:option:algodisplay:comments}

\begin{description}
  \item[\Optscright (default)] right justified side comments (side comments are flushed to the right)
  \item[\Optscleft] left justified side comments (side comments are put right after the code line)
  \item[\Optfillcomment (default)] end mark of comment is flushed to the right so comments fill all
        the width of text
  \item[\Optnofillcomment] end mark of comment is put right after the comment
\end{description}

%---------------------------------
\subsubsection{lines numbers}
\label{sec:optin:algodisplay:linenumber}

\begin{description}
  \item[\Optlinesnumbered:] lines of the algorithms are numbered except for
        comments and input/output (KwInput and KwInOut). You must use \almacp{nllabel}{label}
        to label thoses lines.
  \item[\Optlinesnumberedhidden:] lines of the algorithms are numbered as \optlinesnumbered but
        numbers are not shown. \almac{ShowLn} and \almacp{ShowLnLabel}{label} show the number on line they are
        put.
  \item[\Optcommentsnumbered:] makes comments be numbered if numbering is active.
  \item[\Optinoutnumbered:] makes data input/output be numbered if numbering is active.
  \item[\Optrightnl:] put lines numbers to the right of the algorithm instead of
        left.\par\medskip
  \item[\Optresetcount] the line numbers are reset to 0 at the beginning of
        each algorithm (by default).
  \item[\Optnoresetcount] the contreverse of the precedent. To reset
        the line counter to 0 do:\\
        \texttt{$\backslash$setcounter\{AlgoLine\}\{0\}}
  \item[\Optalgonl] the line numbers will be prefixed with the number of the
        current algorithm. \textbf{Take care} to set the caption of the
        algorithm at the beginning of the environnement, else you will have
        the precedent algorithm number as the current one.
\end{description}

%---------------------------------
\subsubsection{title of algorithms}
\label{sec:option:algodisplay:title}

\begin{description}
  \item[\Opttitlenumbered :] \almacp{TitleOfAlgo}{title}
        prints \textsl{Algorithm n: thetitle} where \emph{n} is the counter
        of the algo.\\
        \textbf{Beware}: \almac{TitleOfAlgo} don't insert an entry in the
        list of algorithms.  So do not use \almac{TitleOfAlgo} with a caption.
        Both increment the counter of the algorithms.
  \item[\Opttitlenotnumbered (default)] the macro
        \texttt{$\backslash$TitleOfAlgo\{title\}} doesn't number the algorithm.
\end{description}


%%%%%%%%%%%%%

\section{Typesetting}

There are eight text types in an algorithm environment:
\begin{enumerate}
  \item The keywords (\textbf{Kw}): Macros which usually indicate words of the language. Some are predefined and
        given with \emph{the algorithm package}.

        The user can define his own language keywords by using the different macros presented in
        \autoref{sec_deflanguage} (see below for a short, non exhaustive list). He can also define simple keywords with
        the \almacpp{SetKw}{Kw}{thetext} macro.
  \item The Functions: (\textbf{Func}) Macros defined by the user which denote local functions or other algorithms
        defined in the text. (See also function environment at~\autoref{sec_envi}, which defines not only function
        keyword but algorithm of the function.

        They are defined using \almacpp{SetKwFunction}{KwFn}{Fn} where $\backslash$KwFn will be the macro and
        \FuncSty{Fn} the text printed.
  \item The Arguments (\textbf{Arg}): The arguments of the \emph{Kw} or
        \emph{Func} macros.
  \item The procedure and function name environment style (\almac{ProcNameSty} and \almac{ProcNameFnt}): The type
        style of the caption of \emph{procedure} and \emph{function} environment.
  \item The arguments of procedure and function environments style (\almac{ProcArgSty} and \almac{ProcArgFnt}): the
        type style of the argument of \emph{procedure} and \emph{function} environments.
  \item Data (\textbf{Data}): A type of text different from the default.  You can use it as you want, and can be
        useful for example to emphasize a Data structure or denotes some important variables.

        They are defined with the help of the \almacpp{SetKwData}{KwDat}{data} macro, where $\backslash$KwDat will be the
        macro and \DataSty{data} the text printed.
  \item Block markers: style of keywords that are print at begin and end of block when
        \optblockmarkers option is set or \almac{AlgoDisplayBlockMarkers} macro used. By default,
        \almac{BlockMarkersSty} is set to \almac{KwSty}.
  \item The text (the default): All the remaining text of the algorithm.
\end{enumerate}


%%%%%%%%%%%%%

\section{Commands provided with the package}

Note that if you define macros outside the algorithm environment they are available in all the document and, in
particular, you can use them inside all algorithms without redefining them. Be careful you can't use macros
beginning a block outside an algorithm environment.

%----------
\subsection{global code typesetting commands}\label{sec:basiccommands}

\begin{description}
  \item[\Almac{;}] marks the end of a line. \textbf{Don't forget it !}. By
        default, it prints a `;'. You can change this with \almac{DontPrintSemicolon}.
  \item[\Almac{DontPrintSemicolon}] the `;' are no more printed at the
        end of each line.
  \item[\Almac{PrintSemicolon}] prints a `; ' at the end of each
        line (by default)
  \item[\Almac{BlankLine}] prints a blank line. In fact puts a
        vertical space of one \texttt{ex}.
  \item[\Almac{Indp}] indents plus $\rightarrow$ the text is shifted to the right.
  \item[\Almac{Indm}] indents minus $\rightarrow$ the text is shifted to the left.
  \item[\Almacppp{SetStartEndCondition}{typo1}{typo2}{typo3}] which sets typo around
        condition in \texttt{For}, \texttt{If}, \texttt{Switch}, \texttt{Case} and
        \texttt{Repeat} macros. First two are used around \texttt{For}, \texttt{If},
        \texttt{Switch} conditions, First and third are used for \texttt{Case} and
        \texttt{Repeat} condition. Default definition is:\\ \verb+\SetStartEndCondition{ }{ }{}+.\\
        A common alternative is \verb+\SetStartEndCondition{ (}{) }{)}+.\\
        It can also be used to remove space around condition, for example if you want python style
        commands: \verb+\SetStartEndCondition{ }{}{}+ and \verb+\SetKwFor{For}{for}{:}{}+
  \item[\Almac{AlgoDisplayBlockMarkers}] that prints begin and end markers at the start and end
        of all block. These begin and end keywords could be specified by using
        \almacpp{SetAlgoBlockMarkers{begin keywords}{end keywords}} command. By default, these
        keywords are not printed but \emph{begin} and \emph{end} are default keywords used if
        \verb+\AlgoDisplayBlockMarkers+ is called.
\end{description}

%----------
\subsection{algorithm environment, caption, list of algorithms, ...}\label{sec:titlemacros}

\subsubsection{caption, title and changind reference of algorithms}
\label{sec:captionmacros}

Algorithm environment are float environment. So you can use classical \almac{caption}, \almacp{listofalgorithms},
\Almac{label}. If you want a title but not a caption (for example to not add an enter in the list of algorithm)
you have \almacp{TitleOfAlgo}. And if you want to name your algorithm and not number it, you can change the
reference of it by using \almacp{SetAlgoRefName}{ref}:

\begin{description}
  \item[\Almacp{caption}{thetitle}] works as classical caption of figures. It inserts an entry in the list of
        algorithms. Should be the standard way to put title of algorithms.
  \item[\Almacp{TitleOfAlgo}{thetitle}] prints: ``Algorithm \no: thetitle'' in the typography and size defined by
        \almac{SetTitleSty}. Puts a vertical space below.\\
        Beware: \almac{TitleOfAlgo} doesn't insert an entry in the list of algorithms.  So don't use \almac{TitleOfAlgo}
        with \almac{caption}. Both increment the counter of the algorithms.\\
        {\small note:\emph{with the \optfrench option prints \emph{Algorithme \no :}}}
  \item[\Almac{listofalgorithms}] inserts the list of all algorithms
        having a \emph{caption}.
  \item[\Almacp{SetAlgoRefName}{ref}] which changes the default ref (number of the algorithm) by the name given in
        parameter. For example \almacp{SetAlgoRefName}{QXY} sets reference of the algorithm to \texttt{QXY}. If you label
        your algorithm and reference it, you will get \texttt{QXY}. On the same manner, entry in the list of algorithm
        will name it \texttt{QXY}.
  \item[\Almacp{SetAlgoRefRelativeSize}{relative integer}] which sets the output size of reference in list of
        algorithms for references set by \almac{SetAlgoRefName}. The default is \almacp{SetAlgoRefRelativeSize}{-2}.
\end{description}

\subsubsection{setting style and layout of algorithm, caption and title}
\label{sec:captionstyle}

The following commands help you to define the style and the layout of the caption:
\begin{description}
  \item[\almacp{SetAlgoCaptionSeparator}{sep}] which sets the separator between title of algorithms (\textbf{Algorithm
          1}) and the name of the algorithm. By default it's ':' and caption looks like "\textbf{Algorithm 2: name}" but now you
        can change it by using for example \SetAlgoCaptionSeparator{.} which will give "\textbf{Algorithm 3. name}".
  \item[\Almac{AlCapSkip}] is the dimension of the distance between algorithm body and caption in
        \emph{plain} and \emph{boxed} mode. You can change by hands or by using \almacp{SetAlCapSkip}{0ex}.
  \item[\Almacp{SetAlCapSkip}{length}] sets the lenght of \almac{AlCapSkip}) dimension between
        algorithm body and caption.
  \item[\Almacp{SetAlCapHSkip}{length}] sets the horizontal skip before Algorithm: in caption when used in ruled algorithm.
  \item[\Almacpp{SetTitleSty}{type style}{type size}] sets the
        typography and size of the titles defined with the macro
        \almacp{TitleOfAlgo}{} (not with $\backslash$caption).
  \item[\Almac{NoCaptionOfAlgo}] doesn't print Algorithm and its number
        in the caption. This macros is \textbf{ONLY} active for
        \emph{``\optalgoruled''} or \emph{``\optruled''} algorithms and for
        the next algorithm. For example, it is useful when the algorithm
        just describes a function and you only want to display the name of
        the function in the caption.
  \item[\Almac{RestoreCaptionOfAlgo}] restores correct captions that was
        corrupted by a \almac{NoCaptionOfAlgo} macro.
  \item[\Almacp{SetAlgoCaptionLayout}{style}] sets global style of the caption; style must be the name of a macro taking one
        argument (the text of the caption). Examples below show how to use it:
        \begin{itemize}
          \item \almacp{SetAlgoCaptionLayout}{centerline} to have centered caption;
          \item \almacp{SetAlgoCaptionLayout}{textbf} to have bold caption.
        \end{itemize}
        If you want to apply two styles in the same time, such as centered bold, you have to define you own macro and
        then use \almac{SetAlgoCaptionLayout} with its name. \almac{AlCapFnt} and \almac{AlCapNameFnt} can change the
        font used in caption, beware of interactions between this three commands.
\end{description}

Note that two length control the layout of ruled, algoruled, boxruled algorithms
caption. \Almac{interspacetitleruled} and \Almac{interspacetitleboxruled} are described \autoref{sec_styleoptions}.

%----------
\subsection{line numbering}\label{sec:linenumbering}

\subsubsection{labelling and numbering lines}
\label{sec:refline}

\texttt{AlgoLine} is the counter used to number the lines. It's a standard counter, so \LaTeX commands works with
it.

\optlinesnumbered, \optlinesnumberedhidden and \optcommentsnumbered (see above \autoref{sec_options}) are the
options controlling auto-numbering of lines. You can also control this feature manually and precisely with the
following commands:
\begin{description}
  \item[\Almac{LinesNumbered}] makes lines of the following algorithms be auto-numbered. This command corresponds to
        \optlinesnumbered option.
  \item[\Almac{LinesNumberedHidden}] makes lines of the following algorithms be auto-numbered, but numbers stay
        hidden. You have to use \almac{ShowLn} and \almac{ShowLnLabel} to see them. This command corresponds to
        \optlinesnumberedhidden option.
  \item[\Almac{LinesNotNumbered}] makes lines of the following algorithms no be auto-numbered.
  \item[\Almacp{nllabel}{label}] macro for labelling lines when auto-numbering is active.
  \item[\Almac{nl}] numbers the line: must \textsc{begin} the line. You can use \almac{label} to label the line and
        reference it further.
  \item[\Almacp{lnl}{label}] numbers and labels the line : must \textsc{begin} the line. Do a
        \textbf{Beware} this has changed from release 3\almac{nl}\almacp{label}{label} in one time. Prefer to use a
        classical \almac{label} as it is more readable.
  \item[\Almacp{nlset}{text}] works as \almac{nl} except that the additional argument is the text to put at the
        beginning of the line. This text becomes the reference if you label it and \almac{ref} will print it instead of
        classical number.
  \item[\almacpp{lnlset}{text}{label}] works for \almac{nlset} as \almac{lnl} for \almac{nl}. Prefer to use a
        classical \almac{label} as it is more readable.
  \item[\Almac{ShowLn}] shows number of the line when \optlinesnumberedhidden is activated.
  \item[\Almacp{ShowLn}{label}] same as precedent but with a label. Prefer to use \almac{ShowLn} with a classical
        \almac{label}.
\end{description}

\subsubsection{setting style of lines numbers}
\label{sec:linestyle}

The following command allows you to change the way line numbers are printed:
\begin{description}
  \item[\Almacppp{SetNlSty}{$<$font$>$}{$<$txt before$>$}{$<$txt after$>$}] defines how to print line numbers:\\
        will print \{$<$font$>$ $<$txt bef$>$ thelinenumber $<$txt aft$>$\}. \\
        By default \almacppp{SetNlSty}{textbf}{}{}.
  \item[\Almacp{SetNlSkip}{length}] sets the value of the space between the line numbers and the text, by default
        1em.
  \item[\Almacp{SetAlgoNLRelativeSize}{number}] sets the relative size of line numbers. By default, line numbers are
        two size smaller than algorithm text. Use this macro to change this behavior. For example,
        \almacp{SetAlgoNlRelativeSize}{$0$} sets it to the same size, \almacp{SetAlgoNlRelativeSize}{$-1$} to one size
        smaller and \almacp{SetAlgoNlRelativeSize}{$1$} to one size bigger.
\end{description}
Example below shows use of these macros:\par\smallskip\noindent%
{\RestyleAlgo{tworuled}\ExampleOfAlgo{algorithm2e_exnlsty.tex}}

%----------

\subsection{math display}
\label{sec:mathdisplay}

If you need to use math display to handle complex mathematics as matrix, using standard
$\backslash$[ $\backslash$] or \$\$ will not allow correct numbering and end line
management. If you don't need line numbers, there is no problem. If you want line numbers,
please use \Alenv{algomathdisplay} environment instead of $\backslash$[ $\backslash$] or
\$\$. It will work as standard math display but line spacing, line numbers, end line will
be managed correcly

%----------

\subsection{standard styles}\label{sec:styles}

\subsubsection{standard font shapes and styles}
\label{sec:fntsty}

Almost every text in algorithm has his own style that can be customized. The following commands correspond to the
different styles used by the package. They can be customized by using corresponding ``\texttt{$\backslash$Set}
commands'' (see \autoref{sec:setfntsty})
\begin{description}
  \item[\Almac{AlFnt}] is used at the beginning of the body of algorithm in order to define the fonts
        used for typesetting algorithms. You can use it elsewhere you want to typeset text as algorithm\\
        For example you can do \SetAlFnt{$\backslash$small$\backslash$sf} to have algorithms typeset in small sf font.
        Default is nothing so algorithm is typeset as the text of the document.
        \medskip

  \item[\Almacp{KwSty}{$<$text$>$}] sets $<$text$>$ in keyword type style.
  \item[\Almacp{FuncSty}{$<$text$>$}] sets $<$text$>$ in function type style.
  \item[\Almacp{ArgSty}{$<$text$>$}] sets $<$text$>$ in argument type
        style.
  \item[\Almacp{DataSty}{$<$text$>$}] sets $<$text$>$ in data typography.
  \item[\Almacp{CommentSty}{$<$text$>$}] sets $<$text$>$ in comment typography.
  \item[\Almacp{NlSty}{$<$text$>$}] sets $<$text$>$ in number line typography.
        \medskip

  \item[\Almacp{ProcNameSty}{$<$text$>$}] sets $<$text$>$ in procedure style of procedure and function environment (by
        default the same as \almacp{AlCapSty}). (see \autoref{sec:captionsty} for more explanations and details)
  \item[\Almacp{ProcFnt}{$<$text$>$}] sets $<$text$>$ in procedure typography of procedure and function environment (by
        default the same as \almacp{AlCapFnt}). (see \autoref{sec:captionsty} for more explanations and details)
  \item[\Almacp{ProcArgSty}{$<$text$>$}] sets $<$text$>$ in argument style of procedure and function environment
        (by default the same as \almacp{AlCapNameSty}). (see \autoref{sec:captionsty} for more explanations and details)
  \item[\Almacp{ProcArgFnt}{$<$text$>$}] sets $<$text$>$ in argument typography of procedure and function environment
        (by default the same as \almacp{AlCapNameFnt}). (see \autoref{sec:captionsty} for more explanations and details)
  \item[\Almacp{BlockMarkersSty}{$<$text$>$}] sets $<$text$>$ in block markers typography
        (by default the same as \almacp{KwSty}) (see \autoref{sec_styleoptions} for more
        explanations and details on block markers).
\end{description}

\subsubsection{caption and title font style}
\label{sec:captionsty}

\almac{AlCapSty}, \almac{AlCapNameSty}, \almac{AlCapFnt}, \almac{AlCapNameFnt}, \almac{ProcSty}, \almac{ProcFnt},
\almac{ProcNameSty}, \almac{ProcNameFnt}, \almac{ProgArgSty}, \almac{ProgArgFnt} and corresponding
``\texttt{$\backslash$Set} commands'' (see \autoref{sec:setcaptionfntsty}) \almac{SetAlCapSty},
\almac{SetAlCapNameSty}, \almac{SetAlCapFnt}, \almac{SetAlCapNameFnt}, \almac{SetProcSty}, \almac{SetProcFnt},
\almac{SetProcNameSty}, \almac{SetProcNameFnt}, \almac{SetProgArgSty}, \almac{SetProgArgFnt} control the way
caption of algorithm and procedure/function environment are printed.

\almac{AlCapSty} and \almac{AlCapFnt} are used to define style and font shape of ``\texttt{Algorithm \#:}'' in
caption. \almac{AlCapNameSty} and \almac{AlCapNameFnt} are used to define style and
font shape of the caption text. In fact a caption \almacp{caption}{my algorithm} is printed as follow :\medskip

\noindent\almacp{AlCapSty}{\almac{AlCapFnt} Algorithm \#:}\almacp{AlCapNameSty}{\almac{AlCapNameFnt} my algorithm}.
\medskip

By default, \almac{AlCapSty} is \texttt{textbf} and \almac{AlCapFnt} is nothing. \almac{AlCapNameSty} keeps text as
it is, and \almac{AlCapNameFnt} do nothing.

\almac{ProcSty} and \almac{ProcFnt} are used to define style and font shape of ``\texttt{Procedure}'' in caption of
procedure and function environment. \almac{ProcNameSty} and \almac{ProcNameFnt} are used to define style and font
shape of the procedure or function name. \almac{ProcArgSty} and \almac{ProgArgFnt} are used to define style and
font shape of arguments in procedure/function environment. In fact a caption \almacp{caption}{Proc(int i)} of
procedure/function environment is printed as follow :\medskip

\noindent\almacp{ProcSty}{\almac{ProcFnt} Procedure}\almacp{ProcNameSty}{\almac{ProcNameFnt} Proc(}\%\\%
\almacp{ProgArgSty}{\almac{ProgArgFnt} int i}\almacp{ProcNameSty}{\almac{ProcNameFnt} )}.\medskip

By default, \almac{ProcSty} is \almac{AlCapSty} and \almac{ProcFnt} is \almac{AlCapFnt}. \almac{ProcNameSty} keeps text as
it is, and \almac{ProcNameFnt} do nothing.

\begin{description}
  \item[\Almacp{AlCapSty}{$<$text$>$}] sets $<$text$>$ in caption title typography, that is the same used, together
        with \almac{AlCapFnt}, to print \texttt{Algorithm \#:}, more precisely it is printed as follow:\\
        \almacp{AlCapSty}{\almac{AlCapFnt} Algorithm \#:}\\
        which gives actually ``\AlCapSty{\AlCapFnt Algorithm \#:}''. By default \almac{AlCapSty} is \texttt{textbf}.
  \item[\Almacp{AlCapNameSty}{$<$text$>$}] sets $<$text$>$ in caption name typography, that is the same used,
        together with \almac{AlCapNameFnt} to print the name of caption you set by calling \almacp{caption}{name}. More
        precisely it is printed as follow:\\
        \almacp{AlCapNameSty}{\almac{AlCapNameFnt} name}\\
        which gives ``\AlCapNameSty{\AlCapNameFnt name}''. By default \almac{AlCapNameSty} is \texttt{textnormal} which
        means print in standard text.
  \item[\Almacp{AlCapFnt}{$<$text$>$}] sets $<$text$>$ in font shape of caption title, that is the same used,
        together with \almac{AlCapSty}, to print \texttt{Algorithm \#:}, more precisely it is printed as follow:\\
        \almacp{AlCapSty}{\almac{AlCapFnt} Algorithm \#:}\\
        which gives actually ``\AlCapSty{\AlCapFnt Algorithm \#:}''. By default \almac{AlCapFnt} is \almac{relax} which
        means keep text as it is.
  \item[\Almacp{AlCapNameFnt}{$<$text$>$}] sets $<$text$>$ in caption name typography, that is the same used,
        together with \almac{AlCapNameSty} to print the name of caption you set by calling \almacp{caption}{name}. More
        precisely it is printed as follow:\\
        \almacp{AlCapNameSty}{\almac{AlCapNameFnt} name}\\
        which gives ``\AlCapNameSty{\AlCapNameFnt name}''. By default \almac{AlCapNameFnt} is \almac{relax} which means
        keep text as it is.
        \medskip

  \item[\Almacp{ProcSty}{$<$text$>$}] sets $<$text$>$ in procedure/function caption title typography, that is the
        same used, together with \almac{ProcFnt}, to print \texttt{Procedure}, more precisely it is printed as follow:\\
        \almacp{ProcSty}{\almac{ProcFnt} Procedure}\\
        which gives actually ``\ProcSty{\ProcFnt Procedure}''. By default \almac{ProcSty} is \almac{AlCapSty}.
  \item[\Almacp{ProcNameSty}{$<$text$>$}] sets $<$text$>$ in procedure name typography, that is the same used,
        together with \almac{ProcNameFnt} to print the name of caption you set by calling \almacp{caption}{Proc(int
          i)}. More  precisely it is printed as follow:\\
        \almacp{ProcNameSty}{\almac{ProcNameFnt} Proc(}\\
        which gives ``\ProcNameSty{\ProcNameFnt Proc(}''. By default \almac{ProcNameSty} is \almac{AlCapNameSty} which
        means print in standard text.
  \item[\Almacp{ProcArgSty}{$<$text$>$}] sets $<$text$>$ in argument of procedure/function typography, that is the
        same used, together with \almac{ProcArgFnt}, to print \texttt{int i} if \almacp{caption}{Proc(int i)} was
        called. More precisely it is printed as follow:\\
        \almacp{ProcArgSty}{\almac{ProcArgFnt} int i}\\
        which gives actually ``\ProcArgSty{\ProcArgFnt int i}''. By default \almac{ProcArgSty} is \almac{AlCapNameSty};
  \item[\Almacp{ProcFnt}{$<$text$>$}] sets $<$text$>$ in font shape of caption title, that is the same used,
        together with \almac{ProcSty}, to print \texttt{Procedure}, more precisely it is printed as follow:\\
        \almacp{ProcSty}{\almac{ProcFnt} Procedure}\\
        which gives actually ``\ProcSty{\ProcFnt Procedure}''. By default \almac{ProcFnt} is \almac{relax} which
        means keep text as it is.
  \item[\Almacp{ProcNameFnt}{$<$text$>$}] sets $<$text$>$ in procedure/function name typography, that is the same
        used, together with \almac{ProcNameSty} to print the name of caption you set by calling \almacp{caption}{Proc(int
          i)}. More  precisely it is printed as follow:\\
        \almacp{ProcNameSty}{\almac{ProcNameFnt} Proc(}\\
        which gives ``\ProcNameSty{\ProcNameFnt Proc(}''. By default \almac{ProcNameFnt} is \almac{relax} which means
        keep text as it is.
  \item[\Almacp{ProcArgFnt}{$<$text$>$}] sets $<$text$>$ in font shape of argument of procedure/environment caption,
        that is the same used, together with \almac{ProcArgSty}, to print \texttt{int i} if \almacp{caption}{int i} was
        called. More precisely it is printed as follow:\\
        \almacp{ProcArgSty}{\almac{ProcFnt} int i}\\
        which gives actually ``\ProcArgSty{\ProcArgFnt int i}''. By default \almac{ProcArgFnt} do nothing.

        \medskip
  \item[\Almacp{AlTitleSty}{$<$text$>$}] is used to typeset ``\texttt{Algorithm \#:}'' in title, together with
        \almac{AlTitleFnt}. You can use it to have text as your titles. Precisely, titles are typeset as follow:\\
        \almacp{AlTitleSty}{\almacp{AlTitleFnt}{Algorithm \#:}}.
  \item[\Almacp{AlTitleFnt}{$<$text$>$}] is used to typeset ``\texttt{Algorithm \#:}'' in title, together with
        \almac{AlTitleSty}. You can use it to have text as your titles. Precisely, titles are typeset as follow:\\
        \almacp{AlTitleSty}{\almacp{AlTitleFnt}{Algorithm \#:}}.
\end{description}

\subsubsection{setting font standard font shapes and styles}
\label{sec:setfntsty}

With the following commands you can customize the style and have the look you want for your algorithms:
\begin{description}
  \item[\Almacp{SetAlFnt}{$<$font$>$}] define the fonts used for typesetting algorithms.
\end{description}
You have to give commands to set the font in argument. You can use it elsewhere you want to typeset text as
algorithm. For example you can do \almacp{SetAlFnt}{$\backslash$\texttt{small}$\backslash$\texttt{sf}} to have
algorithms typeset in small sf font.

The next ones require to give in parameter name of a macro (whithout $\backslash$) which takes one argument. For
example, \almacp{SetAlCapFnt}{textbf} (see \autoref{sec:captionstyle}) defines the default behaviour of
\almac{AlCapFnt}. If you want to do more complicated thing, you should define your own macro and give it to
\almac{SetAlCapFnt} or \almac{SetAlCapNameFnt}. Here are two examples:
\begin{itemize}
  \item $\backslash$\texttt{newcommand\{}$\backslash$\texttt{mycapfn\}[1]\{}$\backslash$\texttt{tiny \#1\}}\almacp{SetAlCapNameFnt}{mycapfnt}
  \item $\backslash$\texttt{newcommand\{}$\backslash$\texttt{mycapfn\}[1]\{}$\backslash$\texttt{textsl\{}$\backslash$\texttt{small \#1\}\}}\almacp{SetAlCapNameFnt}{mycapfnt}
\end{itemize}
Here is the complete list of these macros:
\begin{description}
  \item[\Almacp{SetKwSty}{$<$font$>$}] sets the Kw typography to $<$font$>$ (by
        default: \textbf{textbf}).
  \item[\Almacp{SetFuncSty}{$<$font$>$}]  sets the function typography
        (by default:  \textbf{texttt}).
  \item[\Almacp{SetArgSty}{$<$font$>$}]  sets the argument typography (by
        default: \textbf{emph}).
  \item[\Almacp{SetDataSty}{$<$font$>$}]  sets the data typography (by
        default: \textbf{textsf}).
  \item[\Almacp{SetCommentSty}{$<$font$>$}]  sets the comment text typography (by
        default: \textbf{texttt}).
  \item[\Almacp{SetNlSty}{$<$font$>$}] sets the number line typography (by default:
        \textbf{$\backslash$relsize\{-2\}})
        \medskip

  \item[\Almacp{SetProcNameSty}{$<$font$>$}] sets caption typography of procedure and function environment (by
        default the same as \almacp{AlCapSty}).
  \item[\Almacp{SetProcArgSty}{$<$font$>$}] sets argument typography of procedure and function environment (by
        default the same as \almacp{AlCapNameSty}).
  \item[\Almacp{SetBlockMarkersSty}{$<$font$>$}] sets block markers typography (by default
        the same as \almacp{KwSty}).
\end{description}

\subsubsection{setting caption and title font style}
\label{sec:setcaptionfntsty}

The following commands allow to redefine \texttt{Fnt} macros. This ones requires to give directly commands that
define the font shape you want. They works as \almacp{SetAlFnt} described above. For example you can do
\almacp{SetAlCapFnt}{$\backslash$\texttt{large}$\backslash$\texttt{color\{red\}}} to have \texttt{Algorithm \#:} in
caption printed in large red font.
\begin{description}
  \item[\Almacp{SetAlCapFnt}{$<$font$>$}] sets the font used for  \{algorithm: \}
        in caption of algorithm (default is set to \almac{relax}).
  \item[\Almacp{SetAlCapNameFnt}{$<$font$>$}] sets the font used by caption text. Default is \almac{relax} and text is
        kept as it is.
  \item[\Almacp{SetAlTitleFnt}{$<$font$>$}] sets the font used in \almac{TitleOfAlgo} command (default is
        set to \texttt{$\backslash$relax}, so text is kept as it is).
\end{description}

The next commands allow to redefine \texttt{Sty} macros for caption or title. As ``\texttt{$\backslash$Set}
commands'' of basic font style (see \autoref{sec:setfntsty}), they require a name of a command in argument,
this command have to take one argument, the text to be typeset. They should be combined
with previous commands to redefine display of caption or title. Examples of use:
\begin{itemize}
  \item
        $\backslash$\texttt{newcommand\{}$\backslash$\texttt{mycapsty\}[1]\{}$\backslash$\texttt{textbf\{}$\backslash$\texttt{emph\{\#1\}\}\}}\almacp{SetAlCapNameSty}{mycapsty}\\
        caption will be print emphased and in bold face.
  \item \almacp{SetAlCapNameFnt}{$\backslash$tiny} set font to tiny size.
  \item if you combine $\backslash$SetAlCapNameSty\{mycapsty\} and
        $\backslash$SetAlCapNameFnt\{$\backslash$tiny\} will give tiny bold empased caption.
\end{itemize}

Now the commands:
\begin{description}
  \item[\Almacp{SetAlCapSty}{$<$commandname$>$}:] sets the command that will be used by \almac{AlCapSty} to define
        style of \texttt{Algorithm \#:} in caption. The argument is a name of a command (without $\backslash$). This
        command have to take one argument, the text to be formatted. Default is set to: \almacp{SetAlCapSty}{textbf}.
  \item[\Almacp{SetAlCapNameSty}{$<$commandname$>$}:] sets the command that will be used by \almac{AlCapNameSty} to
        define style of caption text. The argument is a name of a command (without $\backslash$). This command have to
        take one argument, the text to be formatted. Default is set to: \almacp{SetAlCapSty}{textnormal}.
  \item[\Almacp{SetAlTitleSty}{$<$commandname$>$}] sets the command that will be used by \almac{AlTitleSty} to define
        style of algorithm title given by \almac{TitleOfAlgo} (default is set to \almacp{SetAlTitleSty}{textbf}).


        %                               You can redefine \AlCapFnt and \AlCapNameFnt by giving macro to \Set commands. For
        %                               example, you can do \SetAlCapFnt{\large} to see Algorithm printed in \large font.
        %                               You can redefine \AlCapSty, \AlCapFnt, \AlCapNameSty and \AlCapNameFnt with the
        %                               corresponding \Set command. For the Sty commands, you have to give in parameter
        %                               name of a macro (whithout \)  which takes one argument. For example,
        %                               \SetAlCapFnt{textbf} defines the default behaviour. If you want to do more
        %                               complicated thing, you should define your own macro and give it to \SetAlCapFnt or
        %                               \SetAlCapNameFnt. Here are two examples:
        %                               - \newcommand{\mycapsty}[1]{\tiny #1}\SetAlCapNameSty{mycapsty}
        %                               - \newcommand{\mycapsty}[1]{\textsl{\small #1}}\SetAlCapNameSty{mycapsty}
        %                               Or you can combine the two, for the last example you can also do:
        %                               \SetAlCapNameSty{textsl}\SetAlCapNameFnt{\small}
        %                               Thanks to Jan Stilhammer who gives me the idea of \AlCapNameFnt.

        %                      * ADD: - \AlTitleSty and \SetAlTitleSty commands to set a style for title. These commands
        %                               are defined from a macro taking the text in argument, as \textbf for example. 
        %                               To set the TitleSty you have to give name of the macro (without the '\') 
        %                               to \SetAlTitleSty. For example \SetAlTitleSty{textbf} to set \textbf style.
\end{description}

Note that by combining \texttt{Fnt} and \texttt{Sty} macros you can define almost all styles easily. For example,
the last example above can be define in a simplier way that previously presented by doing:
\begin{itemize}
  \item \almacp{SetAlCapNameSty}{textsl}\almacp{SetAlCapNameFnt}{$\backslash$small}
\end{itemize}

%----------
\subsection{controlling the layout of algorithms\label{sec_styleoptions}}

\begin{description}
  \item[\Almacp{RestyleAlgo}{style}] change the layout of the algorithms as do
        options \emph{boxed}, \emph{boxruled}, \emph{ruled} and \emph{algoruled}.
  \item[\Almacp{RestyleAlgo}{style}] sets the style of the following algorithms
        to that given by this macro (\optplain, \optboxed, \optruled, \optalgoruled)
        unlike those indicated in the options of the package (see options of
        the package).
  \item[\Almac{SetAlgoVlined}] prints a vertical line followed by a little
        horizontal line between the start and the end of each block. Looks
        like that : \rule{0.4pt}{3mm}\rule{0.5mm}{0.4pt}
  \item[\Almac{SetNoline}] Doesn't print vertical lines (by default).
        The block is marked with keywords such as \emph{begin}, \emph{end}.
  \item[\Almac{SetAlgoLined}] prints vertical lines between bloc start-end
        keywords as \emph{begin}, \emph{end}.
  \item[\Almac{SetAlgoLongEnd}] acts like \optlongend option.
  \item[\Almac{SetAlgoShortEnd}] acts like \optshortend option.
  \item[\Almac{SetAlgoNoEnd}] acts like \optnoend option.
  \item[\Almacpp{SetInd}{before rule space}{after rule space}] sets the size of the space before the vertical rule
        and after. In \almac{NoLine} mode the indentation space is the sum of these two values, by default 0.5em and 1em
  \item[\Almacp{Setvlineskip}{length}] sets the value of the vertical space after the little horizontal line which
        closes a block in \optvlined mode.
  \item[\Almacp{SetAlgoSkip}{skip command}] Algorithms puts extra vertical space
        before and after to avoid having text bumping lines of boxed or ruled
        algorithms. By default, this is a \smallskip. You can change this value with
        this macro. The four possibilities are:
        \begin{itemize}
          \item $\backslash$SetAlgoSkip\{\}] for no extra vertical skip
          \item $\backslash$SetAlgoSkip\{smallskip\}] to act as the default behaviour
          \item $\backslash$SetAlgoSkip\{medskip\}] to have a bigger skip
          \item $\backslash$SetAlgoSkip\{bigskip\}] to have the bigger skip
        \end{itemize}
        Note that you can apply the skip you want by defining a macro doing it and
        passing its name (without $\backslash$) to $\backslash$SetAlgoSkip
  \item[\Almacp{SetAlgoInsideSkip}{skip command}] Algorithms puts no extra vertical space
        before and after the core of the algorithm. So text is put right after the lines in boxed or ruled style. To put an
        extra space, use \Almacp{SetAlgoInsideSkip}{skip command}, for example \Almacp{SetAlgoInsideSkip}{smallskip}, like for
        \Almacp{SetAlgoSkip}{skip command}.
  \item[\Almac{algomargin}] this is the value of the margin of all algorithms. You can change it by setting:
        $\backslash$\texttt{setlength\{}\almac{algomargin}\texttt{\}\{2em\}} for example. The default value is the sum of
        the two dimensions \almac{leftskip} and \almac{parindent} when the algorithm2e package is loaded. Note that if
        you change this value, it will take effect with the next algorithm environment. So even if you change it
        \emph{inside} an algorithm environment, it will not affect the current algorithm.
  \item[\Almacp{IncMargin}{length}] increases the size of the \almac{algomargin} by the length given in argument.
  \item[\Almacp{DecMargin}{length}] decreases the size of the \almac{algomargin} by the length given in argument.
  \item[\Almacp{DecMargin}{length}] decreases the size of the \almac{algomargin} by the length given in argument.
  \item[\almacp{SetAlgoNlRelativeSize}{number}] sets the relative size of line number (see
        \autoref{sec:linenumbering}) for more details on this command.
  \item[\almacp{SetAlgoCaptionLayout}{style}] sets the global style of caption (see \autoref{sec:titlemacros} for
        more details).
  \item[\Almac{DisplayBlockMarkers}] acts like \optblockmarkers option: each block will be
        started by a \emph{begin} keyword and be ended by an \emph{end} keywords. This is tricky
        to use but allows to customize syntax to match almost every language (see
        \autoref{code:exgeneric} for examples showing how to use
        it). \Almacpp{SetAlgoBlockMarkers}{begin keyword}{end keyword} defines \emph{begin} and
        \emph{end} keywords that will be used by \verb+\DisplayBlockMarkers+. Default keywords
        are \textbf{begin} and \textbf{end}. but for example you can set
        \verb+\DisplayBlockMarkers{\{}{\}}+ to match c-style syntax.
\end{description}

Some length are used to set the layout of ruled, algoruled and boxruled algorithms caption. These length have no
particular macro to set them but can be changed by classical \almac{setlength} commmand:
\begin{description}
  \item[interspacetitleruled] (2pt by defaut) which controls the vertical space between rules and title in ruled and
        algoruled algorithms.
  \item[interspacetitleboxruled] (2\almac{lineskip} by default) which controls the vertical space between rules and title in
        boxruled algorithms.
\end{description}

%----------
\subsection{comments}
\label{sec:comments}

There are two ways to do comments in algorithm :
\begin{enumerate}
  \item by using a comment macro defined by \almacppp{SetKwComment}{command}{right mark}{left mark} (see below) like
        \almac{tcc};
  \item by using side comment, it means comment put in between (\ ) after control command like if-then-else, for,
        ... macros.
\end{enumerate}

At \autoref{sec:commentsmacros}, you can see how \almac{tcc} is defined and at
\autoref{sec:ifthenelsemacros} you can look at some examples how to use it with \texttt{if then else} like
commands and finally you can look at \autoref{sec:defcommentsmacros} how to define comments and explanations on
the different macros and ways of printing comments. Note also that comments are not numbered by default when using
\optlinesnumbered option. You have to set \optcommentsnumbered to number them also.

The following macro control how comment are typeseted.
\begin{description}
  \item[\Almac{SetSideCommentLeft}] right justified side comments (side comments are flushed to the right),
        equivalent to \optscleft option.
  \item[\Almac{SetSideCommentRight}] left justified side comments (side comments are put right after the code line) ,
        equivalent to \optscright option.
  \item[\Almac{SetFillComment}] end mark of comment is flushed to the right so comments fill all the width of text,
        equivalent to \optfillcomment option.
  \item[\Almac{SetNoFillComment}] end mark of comment is put right after the comment, equivalent to \optnofillcomment
        option.
\end{description}



%*******************************************************************

\section{The predefined language keywords}\label{predefkeywords}

Here are the english keywords predefined in the package. There are other
language predefined macros provided, such as french keywords, see
\autoref{sec_lang} for a list of other language keywords. All these keywords
are defined using macros provided by the package and described in
\autoref{sec_deflanguage}.

%\subsection{english keywords}
\RestyleAlgo{boxed}

%----------
\subsection{Input, output macros...}\label{sec:inputmacros}

\begin{itemize}
  \item $\backslash$KwIn\{input\}\macind{KwIn}
  \item $\backslash$KwOut\{output\}\macind{KwOut}
  \item $\backslash$KwData\{input\}\macind{KwData}
  \item $\backslash$KwResult\{output\}\macind{KwResult}
\end{itemize}

%----------
\subsection{basic keywords and blocks}
\label{sec:basickeywords}

\begin{enumerate}
  \item One simple common keyword:
        \begin{itemize}
          \item $\backslash$KwTo\macind{KwTo}
        \end{itemize}
  \item One keyword requiring an argument:
        \begin{itemize}
          \item $\backslash$KwRet\{[value]\}\macind{KwRet}
          \item $\backslash$Return\{[value]\}\macind{Return}
        \end{itemize}
  \item A block:
        \begin{itemize}
          \item $\backslash$Begin\{block inside\}\macind{Begin}
          \item $\backslash$Begin(\textit{begin comment})\{block inside\}\macind{Begin}
        \end{itemize}
\end{enumerate}

%----------
\subsection{comments}
\label{sec:commentsmacros}

\begin{itemize}
  \item $\backslash$tcc\{line(s) of comment\}\macind{tcc}: comment `` la'' C
  \item $\backslash$tcc*\{right justified side comment\}\macind{tcc*}: comment `` la'' C
  \item $\backslash$tcc*[r]\{right justified side comment, ends the line (default)\}\macind{tcc*[r]}: comment `` la'' C
  \item $\backslash$tcc*[l]\{left justified side comment, ends the line\}\macind{tcc*[l]}: comment `` la'' C
  \item $\backslash$tcc*[h]\{left justified comment, without end line; useful with "if-then-else" macros for
        example\}\macind{tcc*[h]}: comment `` la'' C
  \item $\backslash$tcc*[f]\{right justified comment, without end line; useful with "if-then-else" macros for
        example\}\macind{tcc*[f]}: comment `` la'' C
  \item $\backslash$tcp\{line(s) of comment\}\macind{tcp}: comment `` la'' C++
  \item $\backslash$tcp*\{right justified side comment\}\macind{tcp*}: comment `` la'' C++
  \item $\backslash$tcp*[r]\{right justified side comment, ends the line (default)\}\macind{tcp*[r]}: comment `` la'' C++
  \item $\backslash$tcp*[l]\{left justified side comment, ends the line\}\macind{tcp*[l]}: comment `` la'' C++
  \item $\backslash$tcp*[h]\{left justified comment, without end line; useful with "if-then-else" macros for
        example\}\macind{tcp*[h]}: comment `` la'' C++
  \item $\backslash$tcp*[f]\{right justified comment, without end line; useful with "if-then-else" macros for
        example\}\macind{tcp*[f]}: comment `` la'' C++
\end{itemize}

You can see some examples of this macros with \texttt{if then else} at the end of \autoref{sec:defifthenelsemacros}

%----------
\subsection{if-then-else macros}
\label{sec:ifthenelsemacros}

\begin{itemize}
  \item $\backslash$If\{condition\}\{then block\}\macind{If}
  \item $\backslash$If(\textit{then comment})\{condition\}\{then block\}\macind{If}
  \item $\backslash$uIf\{condition\}\{then block without end\}\macind{uIf}
  \item $\backslash$uIf(\textit{then comment})\{condition\}\{then block without end\}\macind{uIf}
  \item $\backslash$lIf\{condition\}\{then's line text\}\macind{lIf}
  \item $\backslash$lIf(\textit{if comment})\{condition\}\{then's line text\}\macind{lIf}
  \item $\backslash$ElseIf\{elseif block\}\macind{ElseIf}
  \item $\backslash$ElseIf(\textit{elseif comment})\{elseif block\}\macind{ElseIf}
  \item $\backslash$uElseIf\{elseif block without end\}\macind{uElseIf}
  \item $\backslash$uElseIf(\textit{elseif comment})\{elseif block without end\}\macind{uElseIf}
  \item $\backslash$lElseIf\{elseif's line text\}\macind{lElseIf}
  \item $\backslash$lElseIf(\textit{elseif comment})\{elseif's line text\}\macind{lElseIf}
  \item $\backslash$Else\{else block\}\macind{Else}
  \item $\backslash$Else(\textit{else comment})\{else block\}\macind{Else}
  \item $\backslash$uElse\{else block without end\}\macind{uElse}
  \item $\backslash$uElse(\textit{else comment})\{else block without end\}\macind{uElse}
  \item $\backslash$lElse\{else's line text\}\macind{lElse}
  \item $\backslash$lElse(\textit{else comment})\{else's line text\}\macind{lElse}
  \item $\backslash$eIf\{condition\}\{then block\}\{else block\}\macind{eIf}
  \item $\backslash$eIf(\textit{then comment})\{condition\}\{then block\}(\textit{else comment})\{else block\}\macind{eIf}
  \item $\backslash$eIf(\textit{then comment})\{condition\}\{then block\}\{else block\}\macind{eIf}
  \item $\backslash$eIf\{condition\}\{then block\}(\textit{else comment})\{else block\}\macind{eIf}
  \item $\backslash$leIf\{condition\}\{then block\}\{else block\}\macind{eIf}
  \item $\backslash$leIf(\textit{comment})\{condition\}\{then block\}\{else block\}\macind{eIf}
\end{itemize}

%----------
\subsection{multiple condition selection:}
\label{sec:switchmacros}

\begin{itemize}
  \item $\backslash$Switch(\textit{switch comment})\{condition\}\{Switch block\}\macind{Switch}
  \item $\backslash$Switch\{condition\}\{Switch block\}\macind{Switch}
  \item $\backslash$Case\{a case\}\{case block\}\macind{Case}
  \item $\backslash$Case(\textit{case comment})\{a case\}\{case block\}\macind{Case}
  \item $\backslash$uCase\{a case\}\{case block without end\}\macind{uCase}
  \item $\backslash$uCase(\textit{case comment})\{a case\}\{case block without end\}\macind{uCase}
  \item $\backslash$lCase\{a case\}\{case's line\}\macind{lCase}
  \item $\backslash$lCase(\textit{case comment})\{a case\}\{case's line\}\macind{lCase}
  \item $\backslash$Other\{otherwise block\}\macind{Other}
  \item $\backslash$Other(\textit{other comment})\{otherwise block\}\macind{Other}
  \item $\backslash$lOther\{otherwise's line\}\macind{lOther}
  \item $\backslash$lOther(\textit{other comment})\{otherwise's line\}\macind{lOther}
\end{itemize}

%----------
\subsection{loops with "end condition" test at the beginning}
\label{sec:loopfor}

\begin{itemize}
  \item $\backslash$For\{condition\}\{text loop\}\macind{For}
  \item $\backslash$For(\textit{for comment})\{condition\}\{text loop\}\macind{For}
  \item $\backslash$lFor\{condition\}\{line text loop\}\macind{lFor}
  \item $\backslash$lFor(\textit{for comment})\{condition\}\{line text loop\}\macind{lFor}
\end{itemize}
\begin{itemize}
  \item $\backslash$While\{condition\}\{text loop\}\macind{While}
  \item $\backslash$While(\textit{while comment})\{condition\}\{text loop\}\macind{While}
  \item $\backslash$lWhile\{condition\}\{line text loop\}\macind{lWhile}
  \item $\backslash$lWhile(\textit{while comment})\{condition\}\{line text loop\}\macind{lWhile}
\end{itemize}
\begin{itemize}
  \item $\backslash$ForEach\{condition\}\{text loop\}\macind{ForEach}
  \item $\backslash$ForEach(\textit{foreach comment})\{condition\}\{text loop\}\macind{ForEach}
  \item $\backslash$lForEach\{condition\}\{line text loop\}\macind{lForEach}
  \item $\backslash$lForEach(\textit{foreach comment})\{condition\}\{line text loop\}\macind{lForEach}
\end{itemize}
\begin{itemize}
  \item $\backslash$ForAll\{condition\}\{text loop\}\macind{ForAll}
  \item $\backslash$ForAll(\textit{forall comment})\{condition\}\{text loop\}\macind{ForAll}
  \item $\backslash$lForAll\{condition\}\{line text loop\}\macind{lForAll}
  \item $\backslash$lForAll(\textit{forall comment})\{condition\}\{line text loop\}\macind{lForAll}
\end{itemize}

\subsection{loops with "end condition" test at the end}
\label{sec:loprepeat}

\begin{itemize}
  \item $\backslash$Repeat\{end condition\}\{text loop\}\macind{Repeat}
  \item $\backslash$Repeat(\textit{repeat comment})\{end condition\}\{text loop\}(\textit{until comment})\macind{Repeat}
  \item $\backslash$Repeat(\textit{repeat comment})\{end condition\}\{text loop\}\macind{Repeat}
  \item $\backslash$Repeat\{end condition\}\{text loop\}(\textit{until comment})\macind{Repeat}
  \item $\backslash$lRepeat\{end condition\}\{line text loop\}\macind{lRepeat}
  \item $\backslash$lRepeat(\textit{repeat comment})\{end condition\}\{line text loop\}\macind{lRepeat}
\end{itemize}

%----------
\subsection{how default keywords are obtained}
\label{sec:defaultkeyworddefinition}

\begin{enumerate}
  \item \almacpp{SetKwInput}{KwData}{Data}\par
        \almacpp{SetKwInput}{KwResult}{Result}\par
        \almacpp{SetKwInput}{KwIn}{Input}\par
        \almacpp{SetKwInput}{KwOut}{Output}
  \item \almacpp{SetKw}{KwTo}{to}
  \item \almacpp{SetKw}{KwRet}{return}\par
        \almacpp{SetKw}{Return}{return}
  \item \almacppp{SetKwBlock}{Begin}{begin}{end}
  \item \almacppp{SetKwComment}{tcc}{/*}{*/}\par
        \almacppp{SetKwComment}{tcp}{//}{}
  \item \almacphuit{SetKwIF}{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}
  \item {\small\almacphuit{SetKwSwitch}{Switch}{Case}{Other}{switch}{do}{case}{otherwise}{endcase}\texttt{endsw}}
  \item \almacpppp{SetKwFor}{For}{for}{do}{endfor}\par
        \almacpppp{SetKwFor}{While}{while}{do}{endw}\par
        \almacpppp{SetKwFor}{ForEach}{foreach}{do}{endfch}\par
        \almacpppp{SetKwAll}{ForEach}{forall}{do}{endfall}
  \item \almacppp{SetKwRepeat}{Repeat}{repeat}{until}
\end{enumerate}

%*******************************************************************

\section{To define your own language keywords}\label{sec_deflanguage}
Note that all these macros verify if the keywords are already defined and do a
renewcommand if they are. So you can overload the default definitions of this
package with your own.

%----------
\subsection{to define Input, output macros...}\label{sec:definputmacros}

\begin{description}
  \item[\Almacpp{SetKwInput}{Kw}{input}] defines the macro
        \almacp{Kw}{arg} which prints \emph{input} followed by `:' in key
        word typography, and behind the argument \emph{arg}. Typically used
        to define macros such as \almacp{Input}{data} or
        \almacp{Output}{result}. Note that \emph{arg} will be shifted so that
        all the text is vertically aligned and to the right of the `:'.
  \item[\Almacpp{SetKwInOut}{Kw}{input}] works as
        \almacpp{SetKwInput}{Kw}{input}. But the position of the `:' is fixed
        and set by the longest keyword defined by this macro.\par
        \Almacp{ResetInOut}{input} resets the position of the `:' for all
        macros defined previously by \almacpp{SetKwInOut}{Kw}{input}. The
        new position is fixed depending on the size of the text \emph{input}
        given in argument.
\end{description}

%----------
\subsection{to define basic keywords or blocks}\label{sec:defbasickeywords}

\begin{description}\RestyleAlgo{plain}
  \item[\Almacpp{SetKw}{Kw}{thetext}] defines the macro \almac{Kw} which
        defines a keyword \emph{thetext} and prints it in keyword
        typography. It can take one argument: $\backslash$Kw\{arg\}. If so,
        \emph{arg} is printed in argument typography. For example \verb+\Kw{thetext}+
        could give: \KwSty{Kw} \ArgSty{thetext}
  \item[\Almacpp{SetKwHangingKw}{Kw}{thetext}] defines a hanging keyword that should act
        like a combination of \almac{SetKwInput} and \almac{SetKw}. In comparison with
        $\backslash$SetKwInput, it doesn't print ':' at end of keyword and line is numbering if
        \optlinesnumbered is set.\\
        For example \verb+\SetKwHangingKw{HData}{Data$\rightarrow$}+ could gives:\par\vspace{-.5ex}
        \begin{algorithm}[H]
          \KwHData{a list of data and a long description of this data to be sure that text requires several lines to be printed}
        \end{algorithm}\vspace{-1ex}
  \item[\Almacpp{SetKwData}{Kw}{thetext}] defines the macro \almacp{Kw}
        which defines a data text. Prints \emph{thetext} in data typography.
        Note that this macros can takes one argument as function macros.
  \item[\Almacpp{SetKwArray}{Kw}{array}] which defines an array keywords \texttt{Kw} called \emph{array} and printed
        in DataSty style when call with $\backslash$\texttt{Kw}. It can be used with one argument which denotes the
        element index: $\backslash$\texttt{Kw}\{n\} prints \DataSty{array[}\ArgSty{n}\DataSty{]} with \emph{array} in
        \Almac{DataSty} and \emph{n} in \Almac{ArgSty}.
  \item[\Almacppp{SetKwBlock}{Begin}{begin}{end}] defines a macro
        \almacp{Begin}{txt} which denotes a block. The text is surrounded by
        the words \emph{begin} and \emph{end} in keyword typography and
        shifted to the right (indented). In \almac{Vline}\emph{ or }%
        \almac{Line}\emph{ mode} a straight vertical line is added.\\
        \verb+\Begin(side text){text}+ gives also text in a block surrounded by \emph{begin} and
        \emph{end}, but \emph{side text} if put after the \emph{begin} keyword. Combined with
        \Almac{tcc*[f]} macro, it allows you to put comments on the same line as
        \emph{begin}.\par
        You can also use alternativ \almacp{uBegin}{txt} which acts as \almacp{Begin}{txt} but
        without \emph{end}. Useful for example as a part separator that doesn't necessary need
        an \emph{end} keyword.
  \item[\Almacpppp{SetKwProg}{Prog}{Title}{is}{end}] Env is a block with 'Title' (in
        \texttt{CapSty} style) at the beginning followed by args followed by '\texttt{is}' then
        '\texttt{text}' inside a block ended by '\texttt{end}'. If no '\texttt{end}' is
        specified, nothing is written (no blank line is inserted). Useful to typeset function or
        prog. For example:\par
        \noindent\ExampleOfAlgo{algorithm2e_exProg.tex}\par
\end{description}

\subsection{to define keywords as function}
\label{sec:deffunction}

If you want describe the function by an algorithm, use instead \emph{function} or \emph{procedure} environment.

\begin{description}
  \item[\Almacpp{SetKwFunction}{KwFn}{Fn}] defines a macro
        \almacp{KwFn}{arg} which prints \emph{Fn} in Function typography and
        its argument \emph{arg} in argument typography, surrounded by a pair
        of parentheses.

        \almacpp{SetKwFunction}{Dothat}{Do that} defines the macro
        \almacp{DoThat}{this}, which is equivalent to
        \almacp{FuncSty}{Do that(}\almacp{ArgSty}{this}\almacp{FuncSty}{)} which
        gives: \FuncSty{Do that(}\ArgSty{this}\FuncSty{)}.

        Note that you can also use it without
        arguments, it will be printed without `()', example:
        \almacpp{SetKwFunction}{Fn}{TheFunction} use as
        \almac{Fn} gives \FuncSty{TheFunction}.

        Keywords (with or without arguments) and functions defined
        previously in normal text (not in an algorithm environment) can be
        used outside an algorithm environment. You can use it by typing
        \almacp{DoThat}{toto} (for a function defined by
        \almacpp{SetKwFunction}{Dothat}{Do that}), you will obtain
        \FuncSty{Do That(\ArgSty{toto})}.
\end{description}

%----------
\subsection{to define comments}
\label{sec:defcommentsmacros}

\begin{description}
  \item[\Almacppp{SetKwComment}{Comment}{start}{end}] defines a macro
        \almacp{Comment}{text comment} which writes \emph{text comment} between
        \emph{start} and \emph{end}. Note that \emph{start} or \emph{end} can be
        empty.\\
        It defines also \almacp{Comment*}{side comment text} macro which allows to put comment on the same
        line as the code. This macro can take various option to control its behaviour:\\
        \verb+\Comment*[r]{side comment text}+ put the end of line mark (';' by default) and side comment
        text just after and right justified, then end the line. It is the default.\\
        \verb+\Comment*[l]{side comment text}+ same thing but side comment text is left justified.\\
        \verb+\Comment*[h]{side comment text}+ put side comment right after the text. No end of line
        mark is put, and line is not terminated (is up to you to put \verb+\;+ to end the line).\\
        \verb+\Comment*[f]{side comment text}+ same as the previous one but with side comment text right
        justified.
\end{description}

%----------
\subsection{to define if-then-else macros}
\label{sec:defifthenelsemacros}

\begin{description}
  \item[\Almacphuit{SetKwIF}{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}]
        defines several macros to give the opportunity to write all
        if-then-else-elseif-endif possibilities:
        \begin{itemize}
          \item \almacpp{If}{cond}{Then's text}\\
                Then's text is writen in a block (below \texttt{then} and on several lines)
                and terminating by the \texttt{endif} given in the last argument.
          \item \almacpp{If(comment)}{cond}{Then's text}\\
                as previous but put \emph{comment} after \texttt{then} keyword. Usually use with
                comment macro like \almac{tcc}*[f]\{comment\} or \almac{tcp}*[f]\{comment\}
          \item \almacp{ElseIf}{ElseIf's text}\\
                ElseIf's text is writen in a block and terminating by the \texttt{endif}.
          \item \almacp{ElseIf(comment)}{ElseIf's text}\\
                the same with comment.
          \item \almacp{Else}{Else's text}\\
                Else's text is writen in a block and terminating by the \texttt{endif}.
          \item \almacp{Else}{Else's text}\\
                the same with comment.
          \item \almacpp{lIf}{cond}{Then's text}\\
                Then's text is written on the same line as \texttt{then}. No \texttt{endif}
                is printed. Do not put $\backslash$; after \emph{Then's text} neither after \almac{lIf}.
          \item \almacpp{lIf(comment)}{cond}{Then's text}\\
                the same with comment.
          \item \almacp{lElseIf}{ElseIf's text}\\
                ElseIf's text is written on the same line as \texttt{else if}. No \texttt{endif}
                is printed.
          \item \almacp{lElseIf(comment)}{ElseIf's text}\\
                the same with comment.
          \item \almacp{lElse}{Else's text}\\
                Else's text is written on the same line as \texttt{else}. No \texttt{endif}
                is printed.
          \item \almacp{lElse(comment)}{Else's text}\\
                the same with comment.
          \item \almacpp{uIf}{cond}{Then's text} (for uncomplete if)\\
                defines a If block unterminated like in a \almac{eIf} block,
                i.e. don't print the \texttt{endif} or don't put the little
                horizontal line in \emph{Vline} mode (see examples below).
                %     \\\vskip\lineskip
                %     \begin{minipage}{.35\textwidth}\begin{verbatim}
                % \uIF{condition}{
                %    if's block\;
                % }
                % \lElse{else in one line}\;\end{verbatim}
                %     \end{minipage}$\Longrightarrow$%
                %     \begin{minipage}{.4\textwidth}%
                %       \begin{algorithm}[H]
                %         \SetAlgLined
                %         \uIf{condition}{
                %           if's block\;
                %         }
                %         \lElse{else in one line}\;
                %       \end{algorithm}
                %     \end{minipage}
          \item \almacpp{uIf(comment)}{cond}{Then's text}\\
                the same with comment.
          \item \almacp{uElseIf}{ElseIf's text} (for uncomplete elseif)\\
                Same explanation as for \almac{uIf} but with \texttt{else if}.
          \item \almacp{uElseIf(comment)}{ElseIf's text}\\
                the same with comment.
          \item \almacp{uElse}{Else's text} (for uncomplete else)\\
                Same explanation as for \almac{uElseIf} but with \texttt{else}.
          \item \almacp{uElse}{Else's text}\\
                the same with comment.
          \item \almacppp{eIf}{cond}{Then's text}{Else's text}\\
                equivalent to the use of \almac{uIf} followed by \almac{Else}.
        \end{itemize}
\end{description}

The macros which begin with a `l' {\small (l as line)} denote that the text passed in argument will be printed on
the same line while with the others the text is printed in a block and shifted. You should put \almac{;} at the end
of ``l macros''.

The macros which begin with a `u' {\small (u as uncomplete)} denote that the text passed in argument will be
printed in a block not terminated by endif. They are useful to chain different alternatives.

The keywords \emph{then} and \emph{else} are automatically printed.  \emph{cond} is always printed in argument
typography just behind the keyword if.

All this macros can be combined with () and \almac{Comment*} macros to put comments after main keywords as If, Else
or ElseIf (see list of predefined keywords above and example below).

Some examples with \verb+\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}+ the default definition given
in the package:\par\smallskip \ExampleOfAlgo{algorithm2e_ex01.tex}\par---\par
\ExampleOfAlgo{algorithm2e_ex02.tex}\par---\par
%\ExampleOfAlgo{algorithm2e_ex03.tex}\par---\par
\ExampleOfAlgo{algorithm2e_ex04.tex}\par---\par
\ExampleOfAlgo{algorithm2e_ex05.tex}\par---\par
\ExampleOfAlgo{algorithm2e_ex06.tex}\par---\par
\ExampleOfAlgo{algorithm2e_ex07.tex}\par
\RestyleAlgo{boxed}


%----------
\subsection{to define multiple condition selection:}
\label{sec:defswitchmacros}

\begin{description}
  \item[\Almacphuit{SetKwSwitch}{Switch}{Case}{Other}{switch}{do}{case}{otherwise}{endcase}\texttt{endsw}]
        defines several macros to give a complete Switch-do-case-otherwise
        environment:
        \begin{itemize}
          \item \almacpp{Switch}{iden}{switch's block}
          \item \almacpp{Switch(comment)}{iden}{switch's block}
          \item \almacpp{Case}{cond}{Case's block}
          \item \almacpp{Case(comment)}{cond}{Case's block}
          \item \almacpp{uCase}{cond}{Case's block}
          \item \almacpp{uCase(comment)}{cond}{Case's block}
          \item \almacpp{lCase}{cond}{Case's text}
          \item \almacpp{lCase(comment)}{cond}{Case's text}
          \item \almacp{Other}{Otherwise's block}
          \item \almacp{Other(comment)}{Otherwise's block}
          \item \almacp{lOther}{Otherwise's text}
          \item \almacp{lOther(comment)}{Otherwise's text}
        \end{itemize}
\end{description}

The keywords \emph{do} and \emph{endsw} are automatically printed.  \emph{iden} and \emph{cond} are always printed
in argument typography just behind the keywords Switch, Case and Otherwise. Here is an example with the default
keywords:\par\smallskip \ExampleOfAlgo{algorithm2e_exswitch.tex}

As for If-then-elseif-else-endif macro, you can use () to put comments after main keywords.

%----------
\subsection{to define loops with "end condition" test at the beginning}
\label{sec:defloopfor}

\begin{description}
  \item[\Almacpppp{SetKwFor}{For}{for}{do}{endfor}]
        defines a loop environment with stop-test done at the beginning of
        the loop.
        \begin{itemize}
          \item \almacpp{For}{loop's condition}{For's text}
          \item \almacpp{For(comment)}{loop's condition}{For's text}
          \item \almacpp{lFor}{loop's condition}{For's text}
          \item \almacpp{lFor(comment)}{loop's condition}{For's text}
        \end{itemize}
\end{description}

The keywords \emph{do} and \emph{endfor} are automatically printed.  The loop condition is printed in argument
typography. For example:\par\smallskip \ExampleOfAlgo{algorithm2e_exfor.tex}

As for If-then-elseif-else-endif macro, you can use () to put comments after main keywords.

\subsection{to define loops with "end condition" test at the end}
\label{sec:defloprepeat}

\begin{description}
  \item[\Almacppp{SetKwRepeat}{Repeat}{repeat}{until}]
        defines a repeat-until environment (loop with stop-test at the end
        of the loop):
        \begin{itemize}
          \item \almacpp{Repeat}{end loop condition}{the loop}
          \item \almacpp{Repeat(comment after repeat)}{end loop condition}{the loop}
          \item \almacpp{Repeat}{end loop condition}{the loop}(comment after until)
          \item \almacpp{Repeat(comment after repeat)}{end loop condition}{the loop}(comment after until)
          \item \almacpp{lRepeat}{end loop condition}{only one line}
          \item \almacpp{lRepeat(comment)}{end loop condition}{only one line}
        \end{itemize}
\end{description}

It prints the loop condition behind the \emph{until} after the text of the loop.For example:\par\smallskip
\ExampleOfAlgo{algorithm2e_exrepeat.tex}

As for If-then-elseif-else-endif macro, you can use () to put comments after main keywords.

%\clearpage
\section{Other language predefined keywords}\label{sec_lang}

\subsection{french keywords}

Hey, I am a frenchy , so I have defined the same as in
\autoref{predefkeywords} but in french.

\begin{enumerate}
  \item $\backslash$Donnees\{donn\'ees\}\macind{Donnees}\par
        $\backslash$Res\{r\'esultats\}\macind{Res}\par
        $\backslash$Entree\{entr\'ees\}\macind{Entree}\par
        $\backslash$Sortie\{sorties\}\macind{Sortie}\par
  \item $\backslash$KwA\macind{KwA}\par
        $\backslash$Retour\{[valeur]\}\macind{Retour}
  \item $\backslash$Deb\{int\'erieur du bloc\}\macind{Deb}
  \item $\backslash$eSi\{condition\}\{bloc du alors\}\{bloc du sinon\}\macind{eSi}\par
        $\backslash$Si\{condition\}\{bloc du alors\}\macind{Si}\par
        $\backslash$uSi\{condition\}\{bloc du alors sans fin\}\macind{uSi}\par
        $\backslash$lSi\{condition\}\{ligne du alors\}\macind{lSi}\par
        $\backslash$SinonSi\{condition\}\{bloc du sinonsi\}\macind{uSinonSi}\par
        $\backslash$uSinonSi\{condition\}\{bloc du sinonsi sans fin\}\macind{uSinonSi}\par
        $\backslash$lSinonSi\{condition\}\{ligne du sinonsi sans fin\}\macind{lSinonSi}\par
        $\backslash$Sinon\{bloc du sinon\}\macind{Sinon}\par
        $\backslash$uSinon\{bloc du sinon sans fin\}\macind{uSinon}\par
        $\backslash$lSinon\{ligne du sinon\}\macind{lSinon}\par
  \item $\backslash$Suivant\{condition\}\{bloc du Suivant-cas-alors\}\macind{Suivant}
        $\backslash$uCas\{cas o\`u\}\{bloc de ce cas sans fin\}\macind{uCas}\par
        $\backslash$Cas\{cas o\`u\}\{bloc de ce cas\}\macind{Cas}\par
        $\backslash$lCas\{cas o\`u\}\{ligne de ce cas\}\macind{lCas}\par
        $\backslash$Autre\{bloc de l'alternative\}\macind{Autre}\par
        $\backslash$lAutre\{ligne de l'alternative\}\macind{lAutre}\par
  \item $\backslash$Pour\{condition\}\{bloc de la boucle\}\macind{Pour}\par
        $\backslash$lPour\{condition\}\{ligne de la boucle\}\macind{lPour}
  \item $\backslash$Tq\{condition\}\{bloc de la boucle\}\macind{Tq}\par
        $\backslash$lTq\{condition\}\{ligne de la boucle\}\macind{lTq}
  \item $\backslash$PourCh\{condition\}\{bloc de la boucle\}\macind{PourCh}\par
        $\backslash$lPourCh\{condition\}\{ligne de la boucle\}\macind{lPourCh}
  \item $\backslash$PourTous\{condition\}\{bloc de la boucle\}\macind{PourTous}\par
        $\backslash$lPourTous\{condition\}\{ligne de la boucle\}\macind{lPourTous}
  \item $\backslash$Repeter\{condition d'arr\^et\}\{bloc de la boucle\}\macind{Repeter}\par
        $\backslash$lRepeter\{condition d'arr\^et\}\{ligne de la boucle\}\macind{lRepeter}
\end{enumerate}

Here we describe how they are obtained:

\begin{enumerate}
  \item \almacpp{SetKwInput}{Donnes}{Donn\'ees}\par
        \almacpp{SetKwInput}{Res}{R\'esultat}\par
        \almacpp{SetKwInput}{Entree}{Entr\'ees}\par
        \almacpp{SetKwInput}{Sortie}{Sorties}\par
  \item \almacpp{SetKw}{KwA}{\`a}\par
        \almacpp{SetKw}{Retour}{retourner}
  \item \almacppp{SetKwBlock}{Deb}{d\'ebut}{fin}
  \item \almacphuit{SetKwIF}{Si}{SinonSi}{Sinon}{si}{alors}{sinon si}{alors}{finsi}
  \item {\footnotesize\almacphuit{SetKwSwitch}{Suivant}{Cas}{Autre}{suivant}{faire}{cas o\`u}{autres cas}{fin cas}\texttt{fin d'alternative}}
  \item \almacpppp{SetKwFor}{Pour}{pour}{faire}{finpour}\par
  \item \almacpppp{SetKwFor}{Tq}{tant que}{faire}{fintq}\par
  \item \almacpppp{SetKwFor}{PourCh}{pour chaque}{faire}{finprch}
  \item \almacpppp{SetKwFor}{PourTous}{pour tous}{faire}{finprts}
  \item \almacppp{SetKwRepeat}{Repeter}{r\'ep\'eter}{jusqu'\`a}
\end{enumerate}

\subsection{German keywords}

\begin{itemize}
  \item $\backslash$Ein\{Eingabe\}\macind{Ein}\par
        $\backslash$Aus\{Ausgabe\}\macind{Aus}\par
        $\backslash$Daten\{Daten\}\macind{Daten}\par
        $\backslash$Ergebnis\{Ergebnis\}\macind{Ergebnis}
  \item $\backslash$Bis\{bis\}\macind{Bis}\par
        $\backslash$KwZurueck\{zur\"uck\}\macind{KwZurueck}\par
        $\backslash$Zurueck\{zur\"uck\}\macind{Zurueck}
  \item $\backslash$Beginn\{Beginn\}\macind{Beginn}%Begin
  \item $\backslash$Wiederh\{stop condition\}\{loop\}\macind{Wiederh}\par
        $\backslash$lWiederh\{stop condition\}\{line loop\}\macind{lWiederh}%Repeat
  \item $\backslash$eWenn\{condition\}\{then text\}\{else text\}\macind{eWenn}\par
        $\backslash$Wenn\{condition\}\{then text\}\macind{Wenn}\par
        $\backslash$uWenn\{condition\}\{then text without end\}\macind{uWenn}\par
        $\backslash$lWenn\{condition\}\{then line\}\macind{lWenn}\par
        $\backslash$SonstWenn\{condition\}\{elseif text\}\macind{gSonstWenn}\par
        $\backslash$uSonstWenn\{condition\}\{elseif text without end\}\macind{uSonstWenn}\par
        $\backslash$lSonstWenn\{condition\}\{elseif line\}\macind{lSonstWenn}\par
        $\backslash$Sonst\{else text\}\macind{Sonst}\par
        $\backslash$uSonst\{else text without end\}\macind{uSonst}\par
        $\backslash$lSonst\{else line\}\macind{lSonst}\par
  \item $\backslash$Unterscheide\{conditions\}{switch-case-default text}\macind{Unterscheide}%Switch
        $\backslash$Fall\{case of\}\{text\}\macind{Fall}\par
        $\backslash$uFall\{case of\}\{text\}\macind{uFall}\par
        $\backslash$lFall\{case of\}\{line text\}\macind{lFall}\par
        $\backslash$Anderes\{default text\}\macind{Anderes}\par
        $\backslash$lAnderes\{default line\}\macind{lAnderes}\par
  \item $\backslash$Fuer\{condition\}\{loop\}\macind{Fuer}\par
        $\backslash$lFuer\{condition\}\{line loop\}\macind{lFuer}%For
  \item $\backslash$FuerPar\{condition\}\{loop\}\macind{FuerPar}\par%ForPar
        $\backslash$lFuerPar\{condition\}\{line\}\macind{lFuerPar}\par%ForPar
  \item $\backslash$FuerJedes\{condition\}\{loop\}\macind{FuerJedes}\par%ForEach
        $\backslash$lFuerJedes\{condition\}\{line\}\macind{lFuerJedes}\par%ForEach
  \item $\backslash$FuerAlle\{condition\}\{loop\}\macind{FuerAlle}\par%ForAll
        $\backslash$lFuerAlle\{condition\}\{line\}{Ende}\macind{lFuerAlle}\par%ForAll
  \item $\backslash$Solange\{condition\}\{loop\}{Ende}\macind{Solange}\par%While
        $\backslash$lSolange\{condition\}\{line\}\macind{lSolange}\par%While
\end{itemize}

Here we describe how they are obtained:

\begin{itemize}
  \item \almacpp{SetKwInput}{Ein}{Eingabe}\par%KwIn
        \almacpp{SetKwInput}{Aus}{Ausgabe}\par%KwOut
        \almacpp{SetKwInput}{Daten}{Daten}\par%KwData
        \almacpp{SetKwInput}{Ergebnis}{Ergebnis}%KwResult
  \item \almacpp{SetKw}{Bis}{bis}\par%KwTo
        \almacpp{SetKw}{KwZurueck}{zur\"uck}\par%KwRet
        \almacpp{SetKw}{Zurueck}{zur\"uck}%Return
  \item \almacppp{SetKwBlock}{Beginn}{Beginn}{Ende}%Begin
  \item \almacppp{SetKwRepeat}{Wiederh}{wiederhole}{bis}%Repeat
  \item \almacphuit{SetKwIF}{Wenn}{SonstWenn}{Sonst}{wenn}{dann}{sonst wenn}{sonst}{Ende}%IF
  \item
        \almacphuit{SetKwSwitch}{Unterscheide}{Fall}{Anderes}{unterscheide}{tue}{Fall}{sonst}{Ende Fall}\texttt{Ende.}%Switch
  \item \almacpppp{SetKwFor}{Fuer}{f\"ur}{tue}{Ende}%For
  \item \almacpppp{SetKwFor}{FuerPar}{f\"ur}{tue gleichzeitig}{Ende}%ForPar
  \item \almacpppp{SetKwFor}{FuerJedes}{f\"ur jedes}{tue}{Ende}%ForEach
  \item \almacpppp{SetKwFor}{FuerAlle}{f\"ur alle}{tue}{Ende}%ForAll
  \item \almacpppp{SetKwFor}{Solange}{solange}{tue}{Ende}%While
\end{itemize}

\subsection{Portuguese keywords}

\begin{itemize}
  \item $\backslash$Entrada\{Entrada\}\macind{KwEntrada}\par
        $\backslash$Saida\{Sa\'{i}da\}\macind{KwSaida}\par
        $\backslash$Dados\{Dados\}\macind{KwDados}\par
        $\backslash$Resultado\{Resultado\}\macind{KwResultado}
  \item $\backslash$Ate\macind{at\'{e}}\par
        $\backslash$KwRetorna\{[val]\}\macind{KwRetorna}\par
        $\backslash$Retorna\{[val]\}\macind{Retorna}
  \item $\backslash$Iniciob\{inside block\}\macind{Iniciob}
  \item $\backslash$eSe\{condition\}\{then block\}\{else block\}\macind{eSe}\par
        $\backslash$Se\{condition\}\{then block\}\macind{Se}\par
        $\backslash$uSe\{condition\}\{then block without end\}\macind{uSe}\par
        $\backslash$lSe\{condition\}\{then's line text\}\macind{lSe}\par
        $\backslash$Senao\{else block\}\macind{Senao}\par
        $\backslash$uSenao\{else block without else\}\macind{uSenao}\par
        $\backslash$lSenao\{else's line text\}\macind{lSenao}\par
        $\backslash$SenaoSe\{condition\}\{elseif block\}\macind{uSenaoSe}\par
        $\backslash$uSenaoSe\{condition\}\{elseif block without end\}\macind{uSenaoSe}\par
        $\backslash$lSenaoSe\{condition\}\{elseif's line text\}\macind{lSenaoSe}
  \item $\backslash$Selec\{condition\}\{Switch block\}\macind{Selec}\par
        $\backslash$Caso\{a case\}\{case block\}\macind{Caso}\par
        $\backslash$uCaso\{a case\}\{case block without end\}\macind{uCaso}\par
        $\backslash$lCaso\{a case\}\{case's line\}\macind{lCaso}\par
        $\backslash$Outro\{otherwise block\}\macind{Outro}\par
        $\backslash$lOutro\{otherwise's line\}\macind{lOutro}
  \item $\backslash$Para\{condition\}\{text loop\}\macind{Para}\par
        $\backslash$lPara\{condition\}\{line text loop\}\macind{lPara}
  \item $\backslash$ParaPar\{condition\}\{text loop\}\macind{ParaPar}\par
        $\backslash$lParaPar\{condition\}\{line text loop\}\macind{lParaPar}
  \item $\backslash$ParaCada\{condition\}\{text loop\}\macind{ParaCada}\par
        $\backslash$lParaCada\{condition\}\{line text loop\}\macind{lParaCada}
  \item $\backslash$ParaTodo\{condition\}\{text loop\}\macind{ParaTodo}\par
        $\backslash$lParaTodo\{condition\}\{line text loop\}\macind{lParaTodo}
  \item $\backslash$Enqto\{stop condition\}\{text loop\}\macind{Enqto}\par
        $\backslash$lEnqto\{stop condition\}\{text loop\}\macind{lEnqto}
  \item $\backslash$Repita\{stop condition\}\{text loop\}\macind{Repita}\par
        $\backslash$lRepita\{stop condition\}\{line of the loop\}\macind{lRepita}
\end{itemize}

Here we describe how they are obtained:

\begin{enumerate}
  \item \almacpp{SetKwInput}{Entrada}{Entrada}\par
        \almacpp{SetKwInput}{Saida}{Sa\'{i}da}\par
        \almacpp{SetKwInput}{Dados}{Dados}\par
        \almacpp{SetKwInput}{Resultado}{Resultado}%
  \item \almacpp{SetKw}{Ate}{at\'{e}}
        \almacpp{SetKw}{KwRetorna}{retorna}\par
        \almacpp{SetKw}{Retorna}{retorna}\par
  \item \almacppp{SetKwBlock}{Inicio}{in\'{i}cio}{fim}%
  \item \almacphuit{SetKwIF}{Se}{SenaoSe}{Senao}{se}{ent\~{a}o}{sen\~{a}o se}{sen\~{a}o}{fim se}%
  \item \almacphuit{SetKwSwitch}{Selec}{Caso}{Outro}{selecione}{fa\c{c}a}{caso}{sen\~{a}o}{fim caso}\texttt{fim selec}%
  \item \almacpppp{SetKwFor}{Para}{para}{fa\c{c}a}{fim para}%
  \item \almacpppp{SetKwFor}{ParaPar}{para}{fa\c{c}a em paralelo}{fim para}
  \item \almacpppp{SetKwFor}{ParaCada}{para cada}{fa\c{c}a}{fim para cada}%
  \item \almacpppp{SetKwFor}{ParaTodo}{para todo}{fa\c{c}a}{fim para todo}%
  \item \almacpppp{SetKwFor}{Enqto}{enquanto}{fa\c{c}a}{fim enqto}%
  \item \almacppp{SetKwRepeat}{Repita}{repita}{at\'{e}}%
\end{enumerate}

\subsection{Italian keywords}

\begin{itemize}
  \item $\backslash$KwIng\{Ingresso\}\macind{KwIng}\par
        $\backslash$KwUsc\{Uscita\}\macind{KwUsc}\par
        $\backslash$KwDati\{Dati\}\macind{KwDati}\par
        $\backslash$KwRisult\{Risultato\}\macind{KwRisult}
  \item $\backslash$KwA\macind{a}\par
        $\backslash$KwRitorna\{ritorna\}\macind{KwRitorna}\par
        $\backslash$Ritorna\{ritorna\}\macind{Ritorna}
  \item $\backslash$Inizio\{inside block\}\macind{Inizio}
  \item $\backslash$Ripeti\{stop condition\}\{text loop\}\macind{Ripeti}\par
        $\backslash$lRipeti\{stop condition\}\{line of the loop\}\macind{lRipeti}
  \item $\backslash$eSea\{condition\}\{then block\}\{else block\}\macind{eSea}\par
        $\backslash$\{condition\}\{then block\}\macind{Sea}\par
        $\backslash$uSea\{condition\}\{then block without end\}\macind{uSea}\par
        $\backslash$lSea\{condition\}\{then's line text\}\macind{lSea}\par
        $\backslash$AltSe\{else block\}\macind{AltSe}\par
        $\backslash$uAltSe\{else block without else\}\macind{uAltSe}\par
        $\backslash$lAltSe\{else's line text\}\macind{lAltSe}\par
        $\backslash$Altrimenti\{condition\}\{elseif block\}\macind{Altrimenti}\par
        $\backslash$uAltrimenti\{condition\}\{elseif block without end\}\macind{uAltrimenti}\par
        $\backslash$lAltrimenti\{condition\}\{elseif's line text\}\macind{lAltrimenti}
  \item $\backslash$Switch\{condition\}\{Switch block\}\macind{Switch}\par
        $\backslash$Case\{a case\}\{case block\}\macind{Case}\par
        $\backslash$uCase\{a case\}\{case block without end\}\macind{uCase}\par
        $\backslash$lCase\{a case\}\{case's line\}\macind{lCase}\par
        $\backslash$Other\{otherwise block\}\macind{Other}\par
        $\backslash$lOther\{otherwise's line\}\macind{lOther}
  \item $\backslash$Per\{condition\}\{text loop\}\macind{Per}\par
        $\backslash$lPer\{condition\}\{line text loop\}\macind{lPer}
  \item $\backslash$PerPar\{condition\}\{text loop\}\macind{PerPar}\par
        $\backslash$lPerPar\{condition\}\{line text loop\}\macind{lPerPar}
  \item $\backslash$PerCiascun\{condition\}\{text loop\}\macind{PerCiascun}\par
        $\backslash$lPerCiascun\{condition\}\{line text loop\}\macind{lPerCiascun}
  \item $\backslash$PerTutti\{condition\}\{text loop\}\macind{PerTutti}\par
        $\backslash$lPerTutti\{condition\}\{line text loop\}\macind{lPerTutti}
  \item $\backslash$Finche\{stop condition\}\{text loop\}\macind{Finche}\par
        $\backslash$lFinche\{stop condition\}\{text loop\}\macind{lFinche}
\end{itemize}

Here we describe how they are obtained:

\begin{enumerate}
  \item \almacpp{SetKwInput}{KwIng}{Ingresso}
  \item \almacpp{SetKwInput}{KwUsc}{Uscita}
  \item \almacpp{SetKwInput}{KwDati}{Dati}
  \item \almacpp{SetKwInput}{KwRisult}{Risultato}
  \item \almacpp{SetKw}{KwA}{a}
  \item \almacpp{SetKw}{KwRitorna}{ritorna}
  \item \almacpp{SetKw}{Ritorna}{ritorna}
  \item \almacppp{SetKwBlock}{Inizio}{inizio}{fine}
  \item \almacppp{SetKwRepeat}{Ripeti}{ripeti}{finch}
  \item \almacphuit{SetKwIF}{Sea}{AltSe}{Altrimenti}{se}{allora}{altrimenti se}{allora}{fine se}
  \item \almacphuit{SetKwSwitch}{Switch}{Case}{Other}{switch}{do}{case}{otherwise}{endcase}\texttt{endsw}
  \item \almacpppp{SetKwFor}{Per}{per}{fai}{fine per}
  \item \almacpppp{SetKwFor}{PerPar}{per}{fai in parallelo}{fine per}
  \item \almacpppp{SetKwFor}{PerCiascun}{per ciascun}{fai}{fine per ciascun}
  \item \almacpppp{SetKwFor}{PerTutti}{per tutti i}{fai}{fine per tutti}
  \item \almacpppp{SetKwFor}{Finche}{finch}{fai}{fine finch}
\end{enumerate}

\subsection{Some Czech keywords}

Here are some czech keywords, please feel free to send me the others.

\begin{itemize}
  % \item $\backslash$AlgVst\macind{AlgVst}
  % \item $\backslash$AlgVyst\macind{AlgVyst}
  \item $\backslash$Vst\macind{Vst}
  \item $\backslash$Vyst\macind{Vyst}
  \item $\backslash$Vysl\macind{Vysl}
\end{itemize}

How they are obtained:

\begin{enumerate}
  % \item \almacp{SetKwInOut}{AlgVst}{Vstup}
  % \item \almacp{SetKwInOut}{AlgVyst}{V\'{y}stup}
  \item \almacp{SetKwInput}{Vst}{Vstup}%
  \item \almacp{SetKwInput}{Vyst}{V\'{y}stup}%
  \item \almacp{SetKwInput}{Vysl}{V\'{y}sledek}%
\end{enumerate}


\section{Known bugs}\label{sec_bugs}

\begin{itemize}
  \item no more known bugs actually; if you find one, please send it to me.
\end{itemize}

\clearpage
\appendix
\section*{Release notes}\label{sec:relnotes}

\begin{verbatim}
% - January 6 2013 - revision 5.0
% * CHANGE: SetKwSwith takes now 9 args: 9th arg is the same as
%            previous 8th arg ('end of switch' keyword). New 8th arg is
%            'end of case' keyword. This is due to change of release
%            3.2 which introduce end after case block... as I never
%            test with longend option, I never see that the 'end
%            switch' used for case was not good.
% * CHANGE: when no end keyword is defined in a block macro, then
%            algorithm2e does no more try to print it. So even with lined or noline
%            option, no empty line is printed (before: a blank end was
%            printed, so a blank line appeared)
% * Internal Change: add some internal function to improve readibility
%                    (thanks to Philip K. F. H\lzenspies)
% * ADD: Block markers. 
%        You can now ask package to put begin and end keywords automatically at begin
%        and end of blocks, it means each group of commands shifted and enclosed in
%        braces.
%        This is tricky to use but, combined with \SetStartEndCondition and
%        redefinition of keywords, you should be abble to simulate any syntax. See
%        examples in documentation where a generic example is derived in pseudo-code,
%        python and C by keeping code and changing only style using block markers
%        macros, \SetStartEndCondition and some redefinition of keywords.
%        These new block markers macros are:
%        - \AlgoDisplayBlockMarkers and \AlgoDontDisplayBlockMarkers
%        - \SetAlgoBlockMarkers{begin marker}{end marker}
%        - \BlockMarkersSty{text} and \SetBlockMarkersSty
%        Note that a new option has also been added: displayblockmarkers
% * ADD: \leIf macro automatically defined by \SetKw: allow to define
%        an if-then-else on a single line.
% * ADD: new macro \SetStartEndCondition{typo1}{typo2}{typo3} which
%        sets typo around condition in For, If, Switch, Case and
%        Repeat macros. First two are used around For, If, Swith
%        conditions, First and third are used for Case and Repeat
%        condition. Default definition is \SetStartEndCondition{ }{ }{}.
%        A common alternative is \SetStartEndCondition{ (}{) }{)}
%        Can also be used to remove space around condition, for
%        example if you want python style commands:
%        \SetStartEndCondition{ }{}{} and \SetKwFor{For}{for}{:}{}
% * ADD: new environment algomathdisplay which allow display math (like inside \[ \] or $$ $$) 
%        handling end line and line number
% * ADD: new command \SetKwProg{Env}{Title}{is}{end} which defines a macro
%        \Env{args}{text}. Env is a block with 'Title' (in \CapSty) at the beginning
%        followed by args followed by 'is' then 'text' is put below inside a block ended
%        by 'end'. If no 'end' is specified, nothing is written (no
%        blank line is inserted). Useful to typeset function or prog for example:
%        \SetKwProg{Fn}{Function}{is}{end} makes \Fn{afunc(i: int) : int}{return 0\;}                    
%        writes: 
%        Function afunc(i: int) : int is
%        | return 0;
%        end
%        or \SetKwProg{Def}{def}{:}{} makes \Def{afunc(i: int)}{return 0\;} writes:
%        def afunc(i: int):
%        | return 0
%        Tip: combine it with \SetKwFunction to write recursive function algorithm. With
%        example above, you could define \SetKwFunction{\Afunc}{afunc} and then write:
%        Def{\Afunc{i:int}{\eIf{i>0}{\KwRet \Afunc{i-1}}{\KwRet 0\;}} that writes:
%        def afunc(i: int):
%        | if(i>0):
%        |     return afunc(i-1)
%        | else:
%        |     return 0
%        with appropriate typo.
% * ADD: option croatian: croation keywords (thanks to Ivan Gavran)
% * ADD: option ngerman: same as german option but so can be used with global option ngerman
%        of babel
% * ADD: option spanish: Spanish support (thanks to Mario Abarca)
% * ADD: unterminated block: useful to add part separator that doesn't necessary need an end
%        keyword.  
%        Designed on the pattern of unterminated if (see \uIf macro) allowing to
%        add a block that is not terminated by a keyword. Such block are defined in the same
%        time as a block is defined by adding a macro beginning with u. So, for example,
%        predefined \SetKwBlock{Begin}{begin}{end} defines now two commands:
%        - \Begin{} as previously which print a begin - end block
%        - \uBegin{} that defines a begin only block
% * FIX: dotocloa option which was broken
% * FIX: uIf and uCase didn't have same behavior when used with
%        noline, vlined or lined option. This is fixed. Side effect: no empty
%        line after an uIf or uCase when used with options lined or vlined
% * FIX: a bug with Repeat Until command when use with side comment on Until
% * FIX: a bug with side text -- text put into () -- of command macro (SetKwIf and so on)
%        which was always setting a ';' even after a \DontPrintSemicolon
% * FIX: a bug with hyperref and chapter definition (thanks to Hubert Meier)
% * FIX: bugs with l macro and side comment
% * FIX: revision number
% * FIX: fix non ascii character (utf8 not yet recognized by all latex engine)
% * FIX: fnum@algocf had an useless parameter which sometimes broke expansion and output an error
% * FIX: works now with multicol package
\end{verbatim}

\clearpage
\listofalgorithms
\clearpage
\printindex
\end{document}
